#!/usr/bin/env node
"use strict";var e=require("fs"),t=require("events"),r=require("child_process"),s=require("path");function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=n(e),i=n(t),a=n(r),c=n(s);class u{constructor(e,t,r,s,n){this._formatName=e,this._description=t,this._extension=r,this._fromJboard=s,this._toJboard=n}get formatName(){return this._formatName}get description(){return this._description}get extension(){return this._extension}get fromJboard(){return this._fromJboard}get toJboard(){return this._toJboard}}const l=[new u("jboard","Representation of a board as a JavaScript object for internal usage.","jboard",JSON.stringify,JSON.parse),new u("gs-weblang-cli-json-board","Representation of a board as a Javascript object used by the gs-weblang-cli tool.","json",(function(e){const t={x:e.head[0],y:e.head[1],sizeX:e.width,sizeY:e.height,table:[]};for(let r=0;r<e.height;r++){const s=[];for(let t=0;t<e.width;t++){const n=e.board[t][r];s.push({blue:n.a,black:n.n,red:n.r,green:n.v})}t.table.unshift(s)}return JSON.stringify(t)}),(function(e){const t=JSON.parse(e),r={head:[t.x,t.y],width:t.sizeX,height:t.sizeY,board:[]};for(let e=0;e<r.width;e++){const s=[];for(let n=0;n<r.height;n++){const o=t.table[r.height-n-1][e];s.push({a:o.blue,n:o.black,r:o.red,v:o.green})}r.board.push(s)}return r})),new u("gbb","GBB/1.0","gbb",(function(e){const t=[];t.push("GBB/1.0"),t.push(`size ${e.width.toString()} ${e.height.toString()}`);for(let r=0;r<e.height;r++)for(let s=0;s<e.width;s++){const n=e.board[s][r];if(n.a+n.n+n.r+n.v===0)continue;let o="cell "+s.toString()+" "+r.toString();n.a>0&&(o+=" Azul "+n.a.toString()),n.n>0&&(o+=" Negro "+n.n.toString()),n.r>0&&(o+=" Rojo "+n.r.toString()),n.v>0&&(o+=" Verde "+n.v.toString()),t.push(o)}return t.push(`head ${e.head[0].toString()} ${e.head[1].toString()}`),t.join("\n")+"\n"}),(function(e){let t=0;const r={width:0,height:0,head:[],board:[]},s=e=>" "===e||"\t"===e||"\r"===e||"\n"===e;function n(){const r=[];for(!function(){for(;t<e.length&&s(e[t]);)t++}();t<e.length&&!s(e[t]);)r.push(e[t]),t++;return r.join("")}function o(e){const t=n();if(!function(e){for(const t of e)if(-1==="0123456789".indexOf(t))return!1;return e.length>0}(t))throw Error(e);const r=parseInt(t,10);if(r<0)throw Error(e);return r}function i(e,t,r){const s=o(r);if(s<e||s>=t)throw Error(r);return s}if("GBB/1.0"!==n())throw Error("GBB/1.0: Board not in GBB/1.0 format.");if("size"!==n())throw Error("GBB/1.0: Board lacks a size declaration.");if(r.width=o("GBB/1.0: Board width is not a number."),r.height=o("GBB/1.0: Board height is not a number."),r.width<=0||r.height<=0)throw Error("GBB/1.0: Board size should be positive.");r.head=[0,0],r.board=[];for(let e=0;e<r.width;e++){const e=[];for(let t=0;t<r.height;t++)e.push({a:0,n:0,r:0,v:0});r.board.push(e)}let a=!1;const c={Azul:"a",A:"a",Negro:"n",N:"n",Rojo:"r",R:"r",Verde:"v",V:"v"};for(;t<e.length;){const s=n();if(""===s)break;if("head"===s){if(a)throw Error("GBB/1.0: Head position cannot be declared twice.");a=!0;const e=i(0,r.width,"GBB/1.0: Invalid head position."),t=i(0,r.height,"GBB/1.0: Invalid head position.");r.head=[e,t]}else{if("cell"!==s)throw Error('GBB/1.0: Malformed board: unknown command "'+s+'".');{const s=i(0,r.width,"GBB/1.0: Invalid cell position."),a=i(0,r.height,"GBB/1.0: Invalid cell position."),u={};for(;t<e.length;){const e=n();if(!(e in c)){t-=e.length;break}const i=c[e];if(i in u)throw Error("GBB/1.0: Color cannot be declared twice.");const l=o("GBB/1.0: Invalid amount of stones.");r.board[s][a][i]=l}}}}return r}))],h={};for(const e of l)h[e.formatName]=e;function p(e){const t=function(e){const t=function(e){const t=e.split(".");return t[t.length-1]}(e);for(const e of l)if(t===e.extension)return e;return h["gs-weblang-cli-json-board"]}(e),r=o.default.readFileSync(e,"utf8");return t.toJboard(r)}class m{constructor(e,t){this._filename=e,this._string=t,this._index=0,this._line=1,this._column=1,this._regions=[]}_clone(){const e=new m(this._filename,this._string);return e._index=this._index,e._line=this._line,e._column=this._column,e._regions=this._regions,e}get filename(){return this._filename}get line(){return this._line}get column(){return this._column}get region(){return this._regions.length>0?this._regions[0]:""}consumeCharacter(){const e=this._clone();return"\n"===e.peek()?(e._line++,e._column=1):e._column++,e._index++,e}consumeString(e){let t=this._clone();for(const r of e)t=t.consumeCharacter();return t}consumeInvisibleCharacter(){const e=this._clone();return e._index++,e}consumeInvisibleString(e){let t=this;for(const r of e)t=t.consumeInvisibleCharacter();return t}startsWith(e){const t=this._index,r=this._index+e.length;return r<=this._string.length&&this._string.substring(t,r)===e}eof(){return this._index>=this._string.length}peek(){return this._string[this._index]}beginRegion(e){const t=this._clone();return t._regions=[e].concat(t._regions),t}endRegion(){const e=this._clone();return e._regions.length>0&&(e._regions=e._regions.slice(1)),e}}const d=new m("(?)","");class _{constructor(e){"string"==typeof e&&(e={"(?)":e}),this._filenames=Object.keys(e),this._filenames.sort(),this._input=e,this._index=0}moreFiles(){return this._index+1<this._filenames.length}nextFile(){this._index++}readCurrentFile(){if(this._index<this._filenames.length){const e=this._filenames[this._index];return new m(e,this._input[e])}return new m("(?)","")}}const g=Symbol.for("T_EOF"),f=Symbol.for("T_NUM"),b=Symbol.for("T_STRING"),P=Symbol.for("T_UPPERID"),v=Symbol.for("T_LOWERID"),T=Symbol.for("T_PROGRAM"),S=Symbol.for("T_INTERACTIVE"),y=Symbol.for("T_PROCEDURE"),E=Symbol.for("T_FUNCTION"),w=Symbol.for("T_RETURN"),x=Symbol.for("T_IF"),C=Symbol.for("T_THEN"),N=Symbol.for("T_ELSEIF"),O=Symbol.for("T_ELSE"),k=Symbol.for("T_CHOOSE"),I=Symbol.for("T_WHEN"),R=Symbol.for("T_OTHERWISE"),L=Symbol.for("T_MATCHING"),A=Symbol.for("T_SELECT"),M=Symbol.for("T_ON"),F=Symbol.for("T_REPEAT"),B=Symbol.for("T_FOREACH"),D=Symbol.for("T_IN"),V=Symbol.for("T_WHILE"),H=Symbol.for("T_SWITCH"),G=Symbol.for("T_TO"),U=Symbol.for("T_LET"),$=Symbol.for("T_NOT"),j=Symbol.for("T_DIV"),W=Symbol.for("T_MOD"),q=Symbol.for("T_TYPE"),z=Symbol.for("T_IS"),Y=Symbol.for("T_RECORD"),J=Symbol.for("T_VARIANT"),K=Symbol.for("T_CASE"),Q=Symbol.for("T_FIELD"),Z=Symbol.for("T_UNDERSCORE"),X=Symbol.for("T_TIMEOUT"),ee=Symbol.for("T_LPAREN"),te=Symbol.for("T_RPAREN"),re=Symbol.for("T_LBRACE"),se=Symbol.for("T_RBRACE"),ne=Symbol.for("T_LBRACK"),oe=Symbol.for("T_RBRACK"),ie=Symbol.for("T_COMMA"),ae=Symbol.for("T_SEMICOLON"),ce=Symbol.for("T_ELLIPSIS"),ue=Symbol.for("T_RANGE"),le=Symbol.for("T_GETS"),he=Symbol.for("T_PIPE"),pe=Symbol.for("T_ARROW"),me=Symbol.for("T_ASSIGN"),de=Symbol.for("T_EQ"),_e=Symbol.for("T_NE"),ge=Symbol.for("T_LE"),fe=Symbol.for("T_GE"),be=Symbol.for("T_LT"),Pe=Symbol.for("T_GT"),ve=Symbol.for("T_AND"),Te=Symbol.for("T_OR"),Se=Symbol.for("T_CONCAT"),ye=Symbol.for("T_PLUS"),Ee=Symbol.for("T_MINUS"),we=Symbol.for("T_TIMES"),xe=Symbol.for("T_POW");class Ce{constructor(e,t,r,s){this._tag=e,this._value=t,this._startPos=r,this._endPos=s}toString(){const e=this._tag,t="symbol"==typeof e?Symbol.keyFor(e).substring(2):e;switch(t){case"NUM":case"STRING":case"UPPERID":case"LOWERID":return t+'("'+this._value.toString()+'")';default:return t}}get tag(){return this._tag}get value(){return this._value}get startPos(){return this._startPos}get endPos(){return this._endPos}}const Ne=Symbol.for("N_Main"),Oe=Symbol.for("N_DefProgram"),ke=Symbol.for("N_DefInteractiveProgram"),Ie=Symbol.for("N_DefProcedure"),Re=Symbol.for("N_DefFunction"),Le=Symbol.for("N_DefType"),Ae=Symbol.for("N_StmtBlock"),Me=Symbol.for("N_StmtReturn"),Fe=Symbol.for("N_StmtIf"),Be=Symbol.for("N_StmtRepeat"),De=Symbol.for("N_StmtForeach"),Ve=Symbol.for("N_StmtWhile"),He=Symbol.for("N_StmtSwitch"),Ge=Symbol.for("N_StmtAssignVariable"),Ue=Symbol.for("N_StmtAssignTuple"),$e=Symbol.for("N_StmtProcedureCall"),je=Symbol.for("N_PatternWildcard"),We=Symbol.for("N_PatternVariable"),qe=Symbol.for("N_PatternNumber"),ze=Symbol.for("N_PatternStructure"),Ye=Symbol.for("N_PatternTuple"),Je=Symbol.for("N_PatternTimeout"),Ke=Symbol.for("N_ExprVariable"),Qe=Symbol.for("N_ExprConstantNumber"),Ze=Symbol.for("N_ExprConstantString"),Xe=Symbol.for("N_ExprChoose"),et=Symbol.for("N_ExprMatching"),tt=Symbol.for("N_ExprList"),rt=Symbol.for("N_ExprRange"),st=Symbol.for("N_ExprTuple"),nt=Symbol.for("N_ExprStructure"),ot=Symbol.for("N_ExprStructureUpdate"),it=Symbol.for("N_ExprFunctionCall"),at=Symbol.for("N_SwitchBranch"),ct=Symbol.for("N_MatchingBranch"),ut=Symbol.for("N_FieldBinding"),lt=Symbol.for("N_ConstructorDeclaration");function ht(e){const t=[];for(const r of e.split("\n"))t.push("  "+r);return t.join("\n")}function pt(e){if(void 0===e)return"null";if(e instanceof Array)return"[\n"+mt(e).join(",\n")+"\n]";if(e instanceof Ce)return e.toString();return Symbol.keyFor(e.tag).substring(2)+"(\n"+mt(e.children).join(",\n")+"\n)"}function mt(e){const t=[];for(const r of e)t.push(ht(pt(r)));return t}class dt{constructor(e,t){if(this._tag=e,this._children=t,this._startPos=d,this._endPos=d,this._attributes={},!(t instanceof Array))throw Error("The children of an ASTNode should be an array.")}toMulangLike(){return{tag:this._tag.toString().replace(/(^Symbol\(|\)$)/g,""),contents:this._children.map((e=>void 0===e?"null":e instanceof Array?new dt(Symbol("?"),e).toMulangLike().contents:e instanceof dt?e.toMulangLike():e instanceof Ce?e.toString():"?"))}}toString(){return pt(this)}tagsToString(){this._tag = Symbol.keyFor(this._tag);for (let c of this._children) {if(c && ('tagsToString' in c)) {c.tagsToString();}}}get tag(){return this._tag}get children(){return this._children}set startPos(e){this._startPos=e}get startPos(){return this._startPos}set endPos(e){this._endPos=e}get endPos(){return this._endPos}get attributes(){return this._attributes}set attributes(e){this._attributes=e}}class _t extends dt{constructor(e){super(Ne,e)}get definitions(){return this.children}}class gt extends dt{constructor(e){super(Oe,[e])}get body(){return this.children[0]}}class ft extends dt{get branches(){return this.children}}class bt extends ft{constructor(e){super(ke,e)}get branches(){return this.children}}class Pt extends dt{constructor(e,t,r){super(Ie,[e,t,r])}get name(){return this.children[0]}get parameters(){return this.children[1]}get body(){return this.children[2]}}class vt extends dt{constructor(e,t,r){super(Re,[e,t,r])}get name(){return this.children[0]}get parameters(){return this.children[1]}get body(){return this.children[2]}}class Tt extends dt{constructor(e,t){super(Le,[e,t])}get typeName(){return this.children[0]}get constructorDeclarations(){return this.children[1]}}class St extends dt{constructor(e){super(Ae,e)}get statements(){return this.children}}class yt extends dt{constructor(e){super(Me,[e])}get result(){return this.children[0]}}class Et extends dt{constructor(e,t,r){super(Fe,[e,t,r])}get condition(){return this.children[0]}get thenBlock(){return this.children[1]}get elseBlock(){return this.children[2]}}class wt extends dt{constructor(e,t){super(Be,[e,t])}get times(){return this.children[0]}get body(){return this.children[1]}}class xt extends dt{get pattern(){return this.children[0]}}class Ct extends xt{constructor(e,t,r){super(De,[e,t,r])}get pattern(){return this.children[0]}get range(){return this.children[1]}get body(){return this.children[2]}}class Nt extends dt{constructor(e,t){super(Ve,[e,t])}get condition(){return this.children[0]}get body(){return this.children[1]}}class Ot extends ft{constructor(e,t){super(He,[e,t])}get subject(){return this.children[0]}get branches(){return this.children[1]}}class kt extends xt{constructor(e,t){super(at,[e,t])}get pattern(){return this.children[0]}get body(){return this.children[1]}}class It extends xt{constructor(e,t){super(ct,[e,t])}get pattern(){return this.children[0]}get body(){return this.children[1]}}class Rt extends dt{constructor(e,t){super(Ge,[e,t])}get variable(){return this.children[0]}get value(){return this.children[1]}}class Lt extends dt{constructor(e,t){super(Ue,[e,t])}get variables(){return this.children[0]}get value(){return this.children[1]}}class At extends dt{constructor(e,t){super($e,[e,t])}get procedureName(){return this.children[0]}get args(){return this.children[1]}}class Mt extends dt{constructor(e){super(je,[])}get boundVariables(){return[]}}class Ft extends dt{constructor(e){super(We,[e])}get variableName(){return this.children[0]}get boundVariables(){return[this.children[0]]}}class Bt extends dt{constructor(e){super(qe,[e])}get number(){return this.children[0]}get boundVariables(){return[]}}class Dt extends dt{constructor(e,t){super(ze,[e,t])}get constructorName(){return this.children[0]}get boundVariables(){return this.children[1]}}class Vt extends dt{constructor(e){super(Ye,e)}get boundVariables(){return this.children}}class Ht extends dt{constructor(e){super(Je,[e])}get boundVariables(){return[]}get timeout(){return parseInt(this.children[0].value,10)}}class Gt extends dt{constructor(e){super(Ke,[e])}get variableName(){return this.children[0]}}class Ut extends dt{constructor(e){super(Qe,[e])}get number(){return this.children[0]}}class $t extends dt{constructor(e){super(Ze,[e])}get string(){return this.children[0]}}class jt extends dt{constructor(e,t,r){super(Xe,[e,t,r])}get condition(){return this.children[0]}get trueExpr(){return this.children[1]}get falseExpr(){return this.children[2]}}class Wt extends ft{constructor(e,t){super(et,[e,t])}get subject(){return this.children[0]}get branches(){return this.children[1]}}class qt extends dt{constructor(e){super(tt,e)}get elements(){return this.children}}class zt extends dt{constructor(e,t,r){super(rt,[e,t,r])}get first(){return this.children[0]}get second(){return this.children[1]}get last(){return this.children[2]}}class Yt extends dt{constructor(e){super(st,e)}get elements(){return this.children}}class Jt extends dt{constructor(e,t){super(nt,[e,t])}get constructorName(){return this.children[0]}get fieldBindings(){return this.children[1]}fieldNames(){const e=[];for(const t of this.fieldBindings)e.push(t.fieldName.value);return e}}class Kt extends dt{constructor(e,t,r){super(ot,[e,t,r])}get constructorName(){return this.children[0]}get original(){return this.children[1]}get fieldBindings(){return this.children[2]}fieldNames(){const e=[];for(const t of this.fieldBindings)e.push(t.fieldName.value);return e}}class Qt extends dt{constructor(e,t){super(it,[e,t])}get functionName(){return this.children[0]}get args(){return this.children[1]}}class Zt extends dt{constructor(e,t){super(ut,[e,t])}get fieldName(){return this.children[0]}get value(){return this.children[1]}}class Xt extends dt{constructor(e,t){super(lt,[e,t])}get constructorName(){return this.children[0]}get fieldNames(){return this.children[1]}}const er=e=>'la palabra clave "'+e+'"';function tr(e,t,r){return 0===e?"ningún "+t:1===e?"un "+t:e.toString()+" "+r}function rr(e){if(e.isInteger())return["m","número","números"];if(e.isBoolean())return["m","booleano","booleanos"];if(e.isColor())return["m","color","colores"];if(e.isDirection())return["f","dirección","direcciones"];if(e.isList()&&e.contentType.isAny())return["f","lista","listas"];if(e.isList()){const t=rr(e.contentType);if(void 0===t)return;{const e=t[2];return["f","lista de "+e,"listas de "+e]}}}function sr(e){const t=rr(e);if(void 0===t)return e.toString();return t[1]}function nr(e){const t=rr(e);if(void 0===t)return"un valor de tipo "+e.toString();{const e=t[0],r=t[1];return"m"===e?"un "+r:"una "+r}}function or(e){const t=rr(e);if(void 0===t)return"de tipo "+e.toString();{const e=t[0],r=t[1];return"m"===e?"un "+r:"una "+r}}function ir(e){return"("===e||")"===e?'un paréntesis abierto "("':"["===e||"]"===e?'un corchete abierto "["':"{"===e||"}"===e?'una llave abierta "{"':e}const ar={definition:"una definición (de programa, función, procedimiento, o tipo)",pattern:'un patrón (comodín "_", constructor aplicado a variables, o tupla)',statement:"un comando",expression:"una expresión","procedure call":"una invocación a un procedimiento","field name":"el nombre de un campo",T_EOF:"el final del archivo",T_NUM:"un número",T_STRING:"una cadena (string)",T_UPPERID:"un identificador con mayúsculas",T_LOWERID:"un identificador con minúsculas",T_PROGRAM:er("program"),T_INTERACTIVE:er("interactive"),T_PROCEDURE:er("procedure"),T_FUNCTION:er("function"),T_RETURN:er("return"),T_IF:er("if"),T_THEN:er("then"),T_ELSE:er("else"),T_REPEAT:er("repeat"),T_FOREACH:er("foreach"),T_IN:er("in"),T_WHILE:er("while"),T_SWITCH:er("switch"),T_TO:er("to"),T_LET:er("let"),T_NOT:er("not"),T_DIV:er("div"),T_MOD:er("mod"),T_TYPE:er("type"),T_IS:er("is"),T_CHOOSE:er("choose"),T_WHEN:er("when"),T_OTHERWISE:er("otherwise"),T_MATCHING:er("matching"),T_SELECT:er("select"),T_ON:er("on"),T_RECORD:er("record"),T_VARIANT:er("variant"),T_CASE:er("case"),T_FIELD:er("field"),T_UNDERSCORE:'un guión bajo ("_")',T_LPAREN:'un paréntesis izquierdo ("(")',T_RPAREN:'un paréntesis derecho (")")',T_LBRACE:'una llave izquierda ("{")',T_RBRACE:'una llave derecha ("}")',T_LBRACK:'un corchete izquierdo ("[")',T_RBRACK:'un corchete derecho ("]")',T_COMMA:'una coma (",")',T_SEMICOLON:'un punto y coma (";")',T_RANGE:'un separador de rango ("..")',T_GETS:'una flecha hacia la izquierda ("<-")',T_PIPE:'una barra vertical ("|")',T_ARROW:'una flecha ("->")',T_ASSIGN:'un operador de asignación (":=")',T_EQ:'una comparación por igualdad ("==")',T_NE:'una comparación por desigualdad ("/=")',T_LE:'un menor o igual ("<=")',T_GE:'un mayor o igual (">=")',T_LT:'un menor estricto ("<")',T_GT:'un mayor estricto (">")',T_AND:'el "y" lógico ("&&")',T_OR:'el "o" lógico ("||")',T_CONCAT:'el operador de concatenación de listas ("++")',T_PLUS:'el operador de suma ("+")',T_MINUS:'el operador de resta ("-")',T_TIMES:'el operador de producto ("*")',T_POW:'el operador de potencia ("^")',LocalVariable:"variable",LocalIndex:"índice",LocalParameter:"parámetro",V_Integer:"un número",V_String:"una cadena",V_Tuple:"una tupla",V_List:"una lista",V_Structure:"una estructura","errmsg:unclosed-multiline-comment":"El comentario se abre pero nunca se cierra.","errmsg:unclosed-string-constant":"La comilla que abre no tiene una comilla que cierra correspondiente.","errmsg:numeric-constant-should-not-have-leading-zeroes":"Las constantes numéricas no se pueden escribir con ceros a la izquierda.","errmsg:identifier-must-start-with-alphabetic-character":"Los identificadores deben empezar con un caracter alfabético (a...z,A...Z).","errmsg:unknown-token":e=>'Símbolo desconocido en la entrada: "'+e+'".',"warning:empty-pragma":"Directiva pragma vacía.","warning:unknown-pragma":e=>'Directiva pragma desconocida: "'+e+'".',"errmsg:unmatched-opening-delimiter":e=>"Se encontró "+ir(e)+" pero nunca se cierra.","errmsg:unmatched-closing-delimiter":e=>'Se encontró un "'+e+'" pero no había '+ir(e)+".","errmsg:unknown-language-option":e=>'Opción desconocida. "'+e+'".',"errmsg:empty-source":"El programa está vacío.","errmsg:expected-but-found":(e,t)=>`Se esperaba ${e}. Se encontró: ${t}.`,"errmsg:pattern-number-cannot-be-negative-zero":'El patrón numérico no puede ser "-0".',"errmsg:return-tuple-cannot-be-empty":"El return tiene que devolver algo.","errmsg:pattern-tuple-cannot-be-singleton":"El patrón para una tupla no puede tener una sola componente. Las tuplas tienen 0, 2, 3, o más componentes, pero no 1.","errmsg:assignment-tuple-cannot-be-singleton":"La asignación a una tupla no puede constar de una sola componente. Las tuplas tienen 0, 2, 3, o más componentes, pero no 1.","errmsg:operators-are-not-associative":(e,t)=>"La expresión usa "+e+" y "+t+", pero estos operadores no se pueden asociar. Quizás faltan paréntesis.","errmsg:obsolete-tuple-assignment":'Se esperaba un comando pero se encontró un paréntesis izquierdo. Nota: la sintaxis de asignación de tuplas "(x1, ..., xN) := y" está obsoleta. Usar "let (x1, ..., xN) := y".',"errmsg:program-already-defined":(e,t)=>"Ya había un programa definido en "+e+".\nNo se puede definir un programa en "+t+".","errmsg:procedure-already-defined":(e,t,r)=>'El procedimiento "'+e+'" está definido dos veces: en '+t+" y en "+r+".","errmsg:function-already-defined":(e,t,r)=>'La función "'+e+'" está definida dos veces: en '+t+" y en "+r+".","errmsg:type-already-defined":(e,t,r)=>`El tipo "${e}" está definido dos veces: en ${t} y en ${r}.`,"errmsg:constructor-already-defined":(e,t,r)=>'El constructor "'+e+'" está definido dos veces: en '+t+" y en "+r+".","errmsg:repeated-field-name":(e,t)=>'El campo "'+t+'" no puede estar repetido para el constructor "'+e+'".',"errmsg:function-and-field-cannot-have-the-same-name":(e,t,r)=>'El nombre "'+e+'" se usa para una función en '+t+" y para un campo en "+r+".","errmsg:source-should-have-a-program-definition":'El código debe tener una definición de "program { ... }".',"errmsg:procedure-should-not-have-return":e=>`El procedimiento "${e}" no debería tener un comando "return".`,"errmsg:function-should-have-return":e=>'La función "'+e+'" debería tener un comando "return".',"errmsg:return-statement-not-allowed-here":'El comando "return" solo puede aparecer como el último comando de una función o como el último comando del programa.',"errmsg:local-name-conflict":(e,t,r,s,n)=>'Conflicto de nombres: "'+e+'" se usa dos veces: como '+t+" en "+r+", y como "+s+" en "+n+".","errmsg:repeated-variable-in-tuple-assignment":e=>`La variable "${e}" está repetida en la asignación de tuplas.`,"errmsg:constructor-used-as-procedure":(e,t)=>'El procedimiento "'+e+'" no está definido. El nombre "'+e+'" es el nombre de un constructor del tipo "'+t+'".',"errmsg:undefined-procedure":e=>'El procedimiento "'+e+'" no está definido.',"errmsg:undefined-function":e=>'La función "'+e+'" no está definida.',"errmsg:procedure-arity-mismatch":(e,t,r)=>'"El procedimiento "'+e+'" espera recibir '+(0,ar["<n>-parameters"])(t)+" pero se lo invoca con "+(0,ar["<n>-arguments"])(r)+".","errmsg:function-arity-mismatch":(e,t,r)=>'La función "'+e+'" espera recibir '+(0,ar["<n>-parameters"])(t)+" pero se la invoca con "+(0,ar["<n>-arguments"])(r)+".","errmsg:structure-pattern-arity-mismatch":(e,t,r)=>'El constructor "'+e+'" tiene '+(0,ar["<n>-fields"])(t)+" pero el patrón tiene "+(0,ar["<n>-parameters"])(r)+".","errmsg:type-used-as-constructor"(e,t){let r;return r=0===t.length?"(no tiene constructores).":1===t.length?"(tiene un constructor: "+t[0]+").":"(sus constructores son: "+t.join(", ")+").",'El constructor "'+e+'" no está definido. El nombre "'+e+'" es el nombre de un tipo '+r},"errmsg:procedure-used-as-constructor":e=>'El constructor "'+e+'" no está definido. El nombre "'+e+'" es el nombre de un procedimiento.',"errmsg:undeclared-constructor":e=>'El constructor "'+e+'" no está definido.',"errmsg:wildcard-pattern-should-be-last":'El comodín "_" debe estar en la última rama.',"errmsg:variable-pattern-should-be-last":e=>'El patrón variable "'+e+'" tiene debe estar en la última rama.',"errmsg:numeric-pattern-repeats-number":e=>'Hay dos ramas distintas para el número "'+e+'".',"errmsg:structure-pattern-repeats-constructor":e=>'Hay dos ramas distintas para el constructor "'+e+'".',"errmsg:structure-pattern-repeats-tuple-arity":e=>"Hay dos ramas distintas para las tuplas de "+e.toString()+" componentes.","errmsg:structure-pattern-repeats-timeout":"Hay dos ramas distintas para el TIMEOUT.","errmsg:pattern-does-not-match-type":(e,t)=>"Los patrones tienen que ser todos del mismo tipo. El patrón debería ser de tipo "+e+"pero es de tipo "+t+".","errmsg:patterns-in-interactive-program-must-be-events":'Los patrones de un "interactive program" deben ser eventos.',"errmsg:patterns-in-interactive-program-cannot-be-variables":"El patrón no puede ser una variable.","errmsg:patterns-in-switch-must-not-be-events":"El patrón no puede ser un evento.","errmsg:structure-construction-repeated-field":(e,t)=>'El campo "'+t+'" está repetido en la instanciación del constructor "'+e+'".',"errmsg:structure-construction-invalid-field":(e,t)=>'El campo "'+t+'" no es un campo válido para el constructor "'+e+'".',"errmsg:structure-construction-missing-field":(e,t)=>'Falta darle valor al campo "'+t+'" del constructor "'+e+'".',"errmsg:structure-construction-cannot-be-an-event":e=>'El constructor "'+e+'" corresponde a un evento, y solamente se puede manejar implícitamente en un programa interactivo (el usuario no puede construir instancias).',"errmsg:forbidden-extension-destructuring-foreach":"El índice de la repetición indexada debe ser un identificador.","errmsg:forbidden-extension-allow-recursion":e=>{const t=[];for(const r of e)t.push("  "+r.caller+" llama a "+r.callee+" ("+r.location.startPos.filename.toString()+":"+r.location.startPos.line.toString()+":"+r.location.startPos.column.toString()+")");return"La recursión está deshabilitada. Hay un ciclo en las invocaciones:\n"+t.join("\n")},"errmsg:patterns-in-foreach-must-not-be-events":"El patrón de un foreach no puede ser un evento.","errmsg:ellipsis":"El programa todavía no está completo.","errmsg:undefined-variable":e=>'La variable "'+e+'" no está definida.',"errmsg:too-few-arguments":e=>'Faltan argumentos para "'+e+'".',"errmsg:expected-structure-but-got":(e,t)=>'Se esperaba una estructura construida con el constructor "'+e+'", pero se recibió '+t+".","errmsg:expected-constructor-but-got":(e,t)=>'Se esperaba una estructura construida con el constructor "'+e+'", pero el constructor recibido es '+t+'".',"errmsg:incompatible-types-on-assignment":(e,t,r)=>'La variable "'+e+'" contenía '+nr(t)+", no se le puede asignar "+nr(r)+'".',"errmsg:incompatible-types-on-list-creation":(e,t,r)=>"Todos los elementos de una lista deben ser del mismo tipo. Los elementos son "+function(e){const t=rr(e);if(void 0===t)return"de tipo "+e.toString();t[0];return t[2]}(t)+", pero el elemento en la posición "+e.toString()+" es "+or(r)+".","errmsg:incompatible-types-on-structure-update":(e,t,r)=>'El campo "'+e+'" es '+or(t)+". No se lo puede actualizar con "+nr(r)+".","errmsg:expected-tuple-value-but-got":e=>"Se esperaba una tupla pero se recibió "+nr(e)+".","errmsg:tuple-component-out-of-bounds":(e,t)=>"Índice fuera de rango. La tupla es de tamaño "+e.toString()+" y el índice es "+t.toString()+".","errmsg:expected-structure-value-but-got":e=>"Se esperaba una estructura pero se recibió "+nr(e)+".","errmsg:structure-field-not-present":(e,t)=>'La estructura no tiene un campo "'+t+'". Los campos son: ['+e.join(", ")+"].","errmsg:primitive-does-not-exist":e=>`La operación primitiva "${e}" no existe o no está disponible.`,"errmsg:primitive-arity-mismatch":(e,t,r)=>'La operación "'+e+'" espera recibir '+(0,ar["<n>-parameters"])(t)+" pero se la invoca con "+(0,ar["<n>-arguments"])(r)+".","errmsg:primitive-argument-type-mismatch"(e,t,r,s,n){let o="El ";var i;return r>1&&(o+=((i=t)>=1&&i<=9?["","primer","segundo","tercer","cuarto","quinto","sexto","séptimo","octavo","noveno"][i]:"#"+i.toString())+" "),o+="parámetro ",o+='de "'+e+'" ',o+="debería ser "+or(s)+" ",o+="pero es "+or(n)+".",o},"errmsg:expected-value-of-type-but-got":(e,t)=>"Se esperaba "+nr(e)+" pero se recibió "+nr(t)+".","errmsg:expected-value-of-some-type-but-got":(e,t)=>"Se esperaba un valor de alguno de los siguientes tipos: "+function(e){const t=[];for(const r of e)t.push(sr(r));return t.join(", ")}(e)+". Pero se recibió "+nr(t)+".","errmsg:expected-values-to-have-compatible-types":(e,t)=>"Los tipos de las expresiones no coinciden: la primera es "+or(e)+" y la segunda es "+or(t)+".","errmsg:switch-does-not-match":"El valor analizado no coincide con ninguna de las ramas del switch.","errmsg:foreach-pattern-does-not-match":"El elemento no coincide con el patrón esperado por el foreach.","errmsg:cannot-divide-by-zero":"No se puede dividir por cero.","errmsg:negative-exponent":"El exponente de la potencia no puede ser negativo.","errmsg:list-cannot-be-empty":"La lista no puede ser vacía.","errmsg:timeout":e=>"La ejecución del programa demoró más de "+e.toString()+"ms.","errmsg:typecheck-failed":(e,t,r)=>function(e,t,r){let s="";for(let n=0;n<e.length;n++)"%"===e[n]&&n+1<e.length?"%"===e[n+1]?(s+="%",n++):"1"===e[n+1]?(s+=nr(t),n++):"2"===e[n+1]?(s+=nr(r),n++):s+="%":s+=e[n];return s}(e,t,r),"errmsg:cannot-move-to":e=>"No se puede mover hacia la dirección "+e+": cae afuera del tablero.","errmsg:cannot-remove-stone":e=>"No se puede sacar una bolita de color "+e+": no hay bolitas de ese color.","TYPE:Integer":"Number","TYPE:String":"String","TYPE:Tuple":"","TYPE:List":"List","TYPE:Event":"Event","CONS:INIT":"INIT","CONS:TIMEOUT":"TIMEOUT","TYPE:Bool":"Bool","CONS:False":"False","CONS:True":"True","TYPE:Color":"Color","CONS:Color0":"Azul","CONS:Color1":"Negro","CONS:Color2":"Rojo","CONS:Color3":"Verde","TYPE:Dir":"Dir","CONS:Dir0":"Norte","CONS:Dir1":"Este","CONS:Dir2":"Sur","CONS:Dir3":"Oeste","PRIM:TypeCheck":"TypeCheck","PRIM:BOOM":"BOOM","PRIM:boom":"boom","PRIM:PutStone":"Poner","PRIM:RemoveStone":"Sacar","PRIM:Move":"Mover","PRIM:GoToEdge":"IrAlBorde","PRIM:EmptyBoardContents":"VaciarTablero","PRIM:numStones":"nroBolitas","PRIM:anyStones":"hayBolitas","PRIM:canMove":"puedeMover","PRIM:next":"siguiente","PRIM:prev":"previo","PRIM:opposite":"opuesto","PRIM:minBool":"minBool","PRIM:maxBool":"maxBool","PRIM:minColor":"minColor","PRIM:maxColor":"maxColor","PRIM:minDir":"minDir","PRIM:maxDir":"maxDir","PRIM:isEmpty":"esVacía","PRIM:head":"primero","PRIM:tail":"sinElPrimero","PRIM:oldTail":"resto","PRIM:init":"comienzo","PRIM:last":"último","<alternative>":e=>"alguna de las siguientes alternativas:\n"+e.map((e=>"  "+e)).join("\n"),"<position>":(e,t,r)=>e+":"+t.toString()+":"+r.toString(),"<n>-parameters":e=>tr(e,"parámetro","parámetros"),"<n>-arguments":e=>tr(e,"argumento","argumentos"),"<n>-fields":e=>tr(e,"campo","campos"),"<pattern-type>":e=>"Event"===e?"evento del programa interactivo":"_TUPLE_"===e.substring(0,7)?"tupla de "+e.substring(7)+" componentes":e},cr={};for(const e in ar)cr[e]=ar[e];cr["TYPE:Color"]="Color",cr["CONS:Color0"]="Blue",cr["CONS:Color1"]="Black",cr["CONS:Color2"]="Red",cr["CONS:Color3"]="Green",cr["TYPE:Dir"]="Dir",cr["CONS:Dir0"]="North",cr["CONS:Dir1"]="East",cr["CONS:Dir2"]="South",cr["CONS:Dir3"]="West",cr["PRIM:PutStone"]="Drop",cr["PRIM:RemoveStone"]="Grab",cr["PRIM:Move"]="Move",cr["PRIM:GoToEdge"]="GoToEdge",cr["PRIM:EmptyBoardContents"]="EmptyBoardContents",cr["PRIM:numStones"]="numStones",cr["PRIM:anyStones"]="anyStones",cr["PRIM:canMove"]="canMove",cr["PRIM:next"]="next",cr["PRIM:prev"]="prev",cr["PRIM:opposite"]="opposite",cr["PRIM:minBool"]="minBool",cr["PRIM:maxBool"]="maxBool",cr["PRIM:minColor"]="minColor",cr["PRIM:maxColor"]="maxColor",cr["PRIM:minDir"]="minDir",cr["PRIM:maxDir"]="maxDir",cr["PRIM:head"]="head",cr["PRIM:tail"]="tail",cr["PRIM:oldTail"]="tail",cr["PRIM:init"]="init",cr["PRIM:last"]="last";const ur=e=>`‘a palavra chave "${e}"`;function lr(e,t,r){return 0===e?"nenhum "+t:1===e?"um "+t:e.toString()+" "+r}const hr={};for(const e in ar)hr[e]=ar[e];hr.definition="uma definição (de programa, função, procedimento, ou tipo)",hr.pattern='um padrão (comodín "_", construtor aplicado a variáveis, ou tupla)',hr.statement="um comando",hr.expression="uma expressão",hr["procedure call"]="uma invocação a um procedimento",hr["field name"]="o nome de um campo",hr.T_EOF="o fim do arquivo",hr.T_NUM="um número",hr.T_STRING="uma corrente (string)",hr.T_UPPERID="um identificador com maiúsculas",hr.T_LOWERID="um identificador com minúsculas",hr.T_PROGRAM=ur("program"),hr.T_INTERACTIVE=ur("interactive"),hr.T_PROCEDURE=ur("procedure"),hr.T_FUNCTION=ur("function"),hr.T_RETURN=ur("return"),hr.T_IF=ur("if"),hr.T_THEN=ur("then"),hr.T_ELSE=ur("else"),hr.T_REPEAT=ur("repeat"),hr.T_FOREACH=ur("foreach"),hr.T_IN=ur("in"),hr.T_WHILE=ur("while"),hr.T_SWITCH=ur("switch"),hr.T_TO=ur("to"),hr.T_LET=ur("let"),hr.T_NOT=ur("not"),hr.T_DIV=ur("div"),hr.T_MOD=ur("mod"),hr.T_TYPE=ur("type"),hr.T_IS=ur("is"),hr.T_RECORD=ur("record"),hr.T_VARIANT=ur("variant"),hr.T_CASE=ur("case"),hr.T_FIELD=ur("field"),hr.T_UNDERSCORE='um sublinhado ("_")',hr.T_LPAREN='um parênteses esquerdo ("(")',hr.T_RPAREN='um parênteses direito (")")',hr.T_LBRACE='uma chave esquerda ("{")',hr.T_RBRACE='uma chave direita ("}")',hr.T_LBRACK='um colchete esquerdo ("[")',hr.T_RBRACK='um colchete direito ("]")',hr.T_COMMA='uma vírgula  (",")',hr.T_SEMICOLON='um ponto e vírgula (";")',hr.T_RANGE='um separador de intervalo ("..")',hr.T_GETS='uma flecha para a esquerda ("<-")',hr.T_PIPE='uma barra vertical ("|")',hr.T_ARROW='uma flecha ("->")',hr.T_ASSIGN='um operador de designação  (":=")',hr.T_EQ='uma comparação por igualdade ("==")',hr.T_NE='uma comparação por desigualdade ("/=")',hr.T_LE='um menor ou igual ("<=")',hr.T_GE='um maior ou igual (">=")',hr.T_LT='um menor estrito ("<")',hr.T_GT='um maior estrito (">")',hr.T_AND='o "e" lógico ("&&")',hr.T_OR='o "ou" lógico ("||")',hr.T_CONCAT='o operador de concatenação de listas ("++")',hr.T_PLUS='o operador de soma ("+")',hr.T_MINUS='o operador de diferença ("-")',hr.T_TIMES='o operador de produto ("*")',hr.T_POW='o operador de potência ("^")',hr.LocalVariable="variável",hr.LocalIndex="índice",hr.LocalParameter="parâmetro",hr.V_Integer="um número",hr.V_String="uma cadeia",hr.V_Tuple="uma tupla",hr.V_List="uma lista",hr.V_Structure="uma estrutura",hr["errmsg:unclosed-multiline-comment"]="O comentário abre mas nunca fecha.",hr["errmsg:unclosed-string-constant"]="As aspas que abrem não possuem as aspas correspondentes que fecham.",hr["errmsg:numeric-constant-should-not-have-leading-zeroes"]="As constantes numéricas não podem ser escritas com zeros à esquerda.",hr["errmsg:identifier-must-start-with-alphabetic-character"]="Os identificadores devem começar com um caractere alfabético (a...z,A...Z).",hr["errmsg:unknown-token"]=e=>`Símbolo desconhecido na entrada: "${e}".`,hr["warning:empty-pragma"]="Diretiva pragma vazia.",hr["warning:unknown-pragma"]=e=>'Diretiva pragma desconhecida: "'+e+'".',hr["errmsg:empty-source"]="O programa está vazio.",hr["errmsg:expected-but-found"]=(e,t)=>`Esperava-se ${e}.\nEncontrado: ${t}.`,hr["errmsg:pattern-number-cannot-be-negative-zero"]='O padrão numérico não pode ser "-0".',hr["errmsg:pattern-tuple-cannot-be-singleton"]="O padrão para uma tupla não pode ter apenas um componente. As tuplas têm 0, 2, 3, ou mais componentes, mas não 1.",hr["errmsg:assignment-tuple-cannot-be-singleton"]="A designação a uma tupla não pode ser  constituída por apenas um componente. As tuplas têm 0, 2, 3, ou mais componentes, mas não 1.",hr["errmsg:operators-are-not-associative"]=(e,t)=>"A expressão usa "+e+" e "+t+", mas estes operadores não podem ser associados. Talvez faltam parênteses.",hr["errmsg:obsolete-tuple-assignment"]='Esperava-se um comando mas não foi encontrado um parênteses esquerdo. Nota: a sintaxe de designação de tuplas "(x1, ..., xN) := y" está obsoleta. Usar "let (x1, ..., xN) := y".',hr["errmsg:program-already-defined"]=(e,t)=>"Já havia um programa definido em "+e+".\nNão é possível definir um programa em "+t+".",hr["errmsg:procedure-already-defined"]=(e,t,r)=>'O procedimiento "'+e+'" está definido duas vezes: em '+t+" e em "+r+".",hr["errmsg:function-already-defined"]=(e,t,r)=>`A função "${e}" está definida duas vezes: em ${t} e em ${r}.`,hr["errmsg:type-already-defined"]=(e,t,r)=>`O tipo "${e}" está definido duas vezes: em ${t} e em ${r}.`,hr["errmsg:constructor-already-defined"]=(e,t,r)=>`O construtor "${e}" está definido duas vezes: em ${t} e em ${r}.`,hr["errmsg:repeated-field-name"]=(e,t)=>'O campo "'+t+'" não pode estar repetido para o construtor "'+e+'".',hr["errmsg:function-and-field-cannot-have-the-same-name"]=(e,t,r)=>'O nome "'+e+'" usa-se para uma função em '+t+" e para um campo em "+r+".",hr["errmsg:source-should-have-a-program-definition"]='O código deve ter uma definição de "program { ... }".',hr["errmsg:procedure-should-not-have-return"]=e=>`O procedimento "${e}" não deveria ter um comando "return".`,hr["errmsg:function-should-have-return"]=e=>'A função "'+e+'" deveria ter um comando "return".',hr["errmsg:return-statement-not-allowed-here"]='O comando "return"  pode aparecer apenas como o último comando de uma função ou como o último comando do programa.',hr["errmsg:local-name-conflict"]=(e,t,r,s,n)=>'Conflito de nomes: "'+e+'" se usa duas vezes: como '+t+" em "+r+", e como "+s+" em "+n+".",hr["errmsg:repeated-variable-in-tuple-assignment"]=e=>`La variável "${e}" está repetida na designação de tuplas.`,hr["errmsg:constructor-used-as-procedure"]=(e,t)=>'O procedimento "'+e+'" não está definido. O nome "'+e+'" é o nome de um construtor do tipo "'+t+'".',hr["errmsg:undefined-procedure"]=e=>'O procedimento "'+e+'" não está definido.',hr["errmsg:undefined-function"]=e=>'A função "'+e+'" não está definida.',hr["errmsg:procedure-arity-mismatch"]=(e,t,r)=>'O procedimento "'+e+'" espera receber '+(0,ar["<n>-parameters"])(t)+" mas é invocado com "+(0,ar["<n>-arguments"])(r)+".",hr["errmsg:function-arity-mismatch"]=(e,t,r)=>'A função "'+e+'" espera receber '+(0,ar["<n>-parameters"])(t)+" mas é invocado com "+(0,ar["<n>-arguments"])(r)+".",hr["errmsg:structure-pattern-arity-mismatch"]=(e,t,r)=>'O construtor "'+e+'" tem '+(0,ar["<n>-fields"])(t)+" mas o padrão tem "+(0,ar["<n>-parameters"])(r)+".",hr["errmsg:type-used-as-constructor"]=(e,t)=>{let r;return r=0===t.length?"(não tem construtores).":1===t.length?"(tem um construtor: "+t[0]+").":"(seus construtores são: "+t.join(", ")+").",'O construtor "'+e+'" não está definido. O nome "'+e+'" é o nome de um tipo '+r},hr["errmsg:procedure-used-as-constructor"]=e=>'O construtor "'+e+'" não está definido. O nome "'+e+'" é o nome de um procedimento.',hr["errmsg:undeclared-constructor"]=e=>'O construtor "'+e+'" não está definido.',hr["errmsg:wildcard-pattern-should-be-last"]='O comodín "_" tem que ser o último ramo do switch.',hr["errmsg:numeric-pattern-repeats-number"]=e=>'Tem dois ramos diferentes para o número "'+e+'".',hr["errmsg:structure-pattern-repeats-constructor"]=e=>'Há dois ramos distintos para o construtor "'+e+'".',hr["errmsg:structure-pattern-repeats-tuple-arity"]=e=>"Há dois ramos distintos para as tuplas de "+e.toString()+" componentes.",hr["errmsg:structure-pattern-repeats-timeout"]="Há dois ramos distintos para o TIMEOUT.",hr["errmsg:pattern-does-not-match-type"]=(e,t)=>'Os padrões devem ser todos do mesmo tipo. O padrão deveria ser de tipo "'+e+'" pero es de tipo "'+t+'".',hr["errmsg:patterns-in-interactive-program-must-be-events"]='Os padrões de um "interactive program" devem ser eventos.',hr["errmsg:patterns-in-switch-must-not-be-events"]='Os padrões de um "switch" não podem ser eventos.',hr["errmsg:structure-construction-repeated-field"]=(e,t)=>'O campo "'+t+'" está repetido em a instanciação do construtor "'+e+'".',hr["errmsg:structure-construction-invalid-field"]=(e,t)=>'O campo "'+t+'" não é um campo válido para o construtor "'+e+'".',hr["errmsg:structure-construction-missing-field"]=(e,t)=>`Falta dar valor ao campo "${t}" do construtor "${e}".`,hr["errmsg:structure-construction-cannot-be-an-event"]=e=>'O construtor "'+e+'" corresponde a um evento, e só pode ser administrado implicitamente em um programa interativo (o usuário não pode construir instâncias).',hr["errmsg:undefined-variable"]=e=>'A variável "'+e+'" não está definida.',hr["errmsg:too-few-arguments"]=e=>'Faltam argumentos para "'+e+'".',hr["errmsg:expected-structure-but-got"]=(e,t)=>'Esperava-se uma estrutura construída com o construtor "'+e+'", mas foi recebido '+t+".",hr["errmsg:expected-constructor-but-got"]=(e,t)=>'Esperava-se uma estrutura construída com o construtor "'+e+'", mas o construtor recebido é '+t+'".',hr["errmsg:incompatible-types-on-assignment"]=(e,t,r)=>'A variável "'+e+'" continha un valor do tipo '+t+", não é possível designar um valor de tipo "+r+'".',hr["errmsg:incompatible-types-on-list-creation"]=(e,t,r)=>"Todos os elementos de uma lista devem ser do mesmo tipo. Os elementos são do tipo "+t+", mas o elemento na posição "+e.toString()+" é do tipo "+r+".",hr["errmsg:incompatible-types-on-structure-update"]=(e,t,r)=>'O campo "'+e+'" é do tipo '+t+". Não pode ser atualizado com um valor do tipo "+r+".",hr["errmsg:expected-tuple-value-but-got"]=e=>`Esperava-se uma tupla mas um valor não foi recebido de tipo ${e}.`,hr["errmsg:tuple-component-out-of-bounds"]=(e,t)=>"Índice fora do intervalo. A tupla é do tamanho "+e.toString()+" e o índice é "+t.toString()+".",hr["errmsg:expected-structure-value-but-got"]=e=>`Se esperaba una estructura pero se recibió un valor de tipo ${e}.`,hr["errmsg:structure-field-not-present"]=(e,t)=>'A estrutura não possui um campo "'+t+'". Os campos são: ['+e.join(", ")+"].",hr["errmsg:primitive-does-not-exist"]=e=>`A operação primitiva "${e}" não existe ou não está disponível.`,hr["errmsg:primitive-arity-mismatch"]=(e,t,r)=>'A operação "'+e+'" espera receber '+(0,ar["<n>-parameters"])(t)+" mas é invocada com "+(0,ar["<n>-arguments"])(r)+".",hr["errmsg:primitive-argument-type-mismatch"]=(e,t,r,s)=>"O parâmetro #"+t.toString()+' da operação "'+e+'" deveria ser do tipo '+r+" mas o argumento é do tipo "+s+".",hr["errmsg:expected-value-of-type-but-got"]=(e,t)=>"Esperava-se um valor do tipo "+e+" mas foi recebido um valor do tipo "+t+".",hr["errmsg:expected-value-of-some-type-but-got"]=(e,t)=>"Esperava-se um valor de algum dos seguintes tipos: "+e.join(", ")+"; mas foi recebido um valor do tipo "+t+".",hr["errmsg:expected-values-to-have-compatible-types"]=(e,t)=>"Os tipos dos valores devem ser compatíveis, mas um é do tipo "+e+" e o outro é do tipo "+t+".",hr["errmsg:switch-does-not-match"]="O valor analisado não coincide com nenhum dos ramos do switch.",hr["errmsg:cannot-divide-by-zero"]="Não é possível dividir por zero.",hr["errmsg:list-cannot-be-empty"]="A lista não pode ser vazia.",hr["errmsg:timeout"]=e=>"A execução do programa demorou mais de "+e.toString()+"ms.",hr["errmsg:cannot-move-to"]=e=>"Não é possível mover para a direção "+e+": cai fora do tabuleiro.",hr["errmsg:cannot-remove-stone"]=e=>"Não é posível retirar uma pedra de cor "+e+": não há pedras dessa cor.",hr["TYPE:Color"]="Cor",hr["CONS:Color0"]="Azul",hr["CONS:Color1"]="Preto",hr["CONS:Color2"]="Vermelho",hr["CONS:Color3"]="Verde",hr["TYPE:Dir"]="Dir",hr["CONS:Dir0"]="Norte",hr["CONS:Dir1"]="Leste",hr["CONS:Dir2"]="Sul",hr["CONS:Dir3"]="Oeste",hr["PRIM:PutStone"]="Colocar",hr["PRIM:RemoveStone"]="Retirar",hr["PRIM:Move"]="Mover",hr["PRIM:GoToEdge"]="IrABorda",hr["PRIM:EmptyBoardContents"]="EsvaziarTabuleiro",hr["PRIM:numStones"]="nroPedras",hr["PRIM:anyStones"]="haPedras",hr["PRIM:canMove"]="podeMover",hr["PRIM:next"]="seguinte",hr["PRIM:prev"]="previo",hr["PRIM:opposite"]="oposto",hr["PRIM:minBool"]="minBool",hr["PRIM:maxBool"]="maxBool",hr["PRIM:minColor"]="minCor",hr["PRIM:maxColor"]="maxCor",hr["PRIM:minDir"]="minDir",hr["PRIM:maxDir"]="maxDir",hr["PRIM:head"]="primeiro",hr["PRIM:tail"]="resto",hr["PRIM:oldTail"]="resto",hr["PRIM:init"]="comeco",hr["PRIM:last"]="ultimo",hr["<alternative>"]=e=>"alguma das seguintes alternativas:\n"+e.map((e=>"  "+e)).join("\n"),hr["<position>"]=(e,t,r)=>e+":"+t.toString()+":"+r.toString(),hr["<n>-parameters"]=e=>lr(e,"parâmetro","parâmetros"),hr["<n>-arguments"]=e=>lr(e,"argumento","argumentos"),hr["<n>-fields"]=e=>lr(e,"campo","campos"),hr["<pattern-type>"]=e=>"Event"===e?"evento do programa interativo":"_TUPLE_"===e.substring(0,7)?"tupla de "+e.substring(7)+" componentes":e;const pr={es:ar,en:cr,pt:hr},mr=e=>pr.es[e],dr=e=>pr.es[e],_r=e=>{const t=dr("<position>");return"string"==typeof t?t:t(e.filename,e.line,e.column)};class gr extends Error{constructor(e,t,r,s,n){super(s),this.isGobstonesException=!0,this.startPos=e,this.endPos=t,this.reason=s,this.args=n;const o=mr(r+":"+s),i="string"==typeof o||void 0===o?o:o(...n);this.message="boom-called"===s?n[0]:i}}class fr extends gr{constructor(e,t,r,s){super(e,t,"warning",r,s)}}class br extends gr{constructor(e,t,r,s){super(e,t,"errmsg",r,s)}}class Pr extends gr{constructor(e,t,r,s){super(e,t,"errmsg",r,s)}}class vr{constructor(e,t,r){this._typeName=e,this._constructorName=t,this._index=r}get typeName(){return this._typeName}get constructorName(){return this._constructorName}get index(){return this._index}}const Tr=Symbol.for("LocalVariable"),Sr=Symbol.for("LocalParameter"),yr=Symbol.for("LocalIndex");class Er{constructor(e,t){this._category=e,this._position=t}get category(){return this._category}get position(){return this._position}}function wr(e,t,r,s){throw new br(e,t,r,s)}class xr{constructor(){this._program=void 0,this._isInteractiveProgram=!1,this._procedures={},this._procedureParameters={},this._functions={},this._functionParameters={},this._types={},this._typeConstructors={},this._constructors={},this._constructorType={},this._constructorFields={},this._fields={},this._localNames={}}get program(){return this._program}isInteractiveProgram(){return this._isInteractiveProgram}isProcedure(e){return e in this._procedures}allProcedureNames(){const e=[];for(const t in this._procedures)e.push(t);return e.sort()}procedureDefinition(e){if(this.isProcedure(e))return this._procedures[e];throw Error("Undefined procedure.")}procedureParameters(e){if(this.isProcedure(e))return this._procedureParameters[e];throw Error("Undefined procedure.")}isFunction(e){return e in this._functions}allFunctionNames(){const e=[];for(const t in this._functions)e.push(t);return e.sort()}functionDefinition(e){if(this.isFunction(e))return this._functions[e];throw Error("Undefined function.")}functionParameters(e){if(this.isFunction(e))return this._functionParameters[e];throw Error("Undefined function.")}isType(e){return e in this._types}typeDefinition(e){if(this.isType(e))return this._types[e];throw Error("Undefined type.")}typeConstructors(e){if(this.isType(e))return this._typeConstructors[e];throw Error("Undefined type.")}isConstructor(e){return e in this._constructors}constructorDeclaration(e){if(this.isConstructor(e))return this._constructors[e];throw Error("Undefined constructor.")}constructorType(e){if(this.isConstructor(e))return this._constructorType[e];throw Error("Undefined constructor.")}constructorFields(e){if(this.isConstructor(e))return this._constructorFields[e];throw Error("Undefined constructor.")}isField(e){return e in this._fields}fieldDescriptor(e){if(this.isField(e))return this._fields[e];throw Error("Undefined field.")}defProgram(e){void 0!==this._program&&wr(e.startPos,e.endPos,"program-already-defined",[_r(this._program.startPos),_r(e.startPos)]),this._program=e}defInteractiveProgram(e){this.defProgram(e),this._isInteractiveProgram=!0}defProcedure(e){const t=e.name.value;t in this._procedures&&wr(e.name.startPos,e.name.endPos,"procedure-already-defined",[t,_r(this._procedures[t].startPos),_r(e.startPos)]);const r=[];for(const t of e.parameters)r.push(t.value);this._procedures[t]=e,this._procedureParameters[t]=r}defFunction(e){const t=e.name.value;if(t in this._functions)wr(e.name.startPos,e.name.endPos,"function-already-defined",[t,_r(this._functions[t].startPos),_r(e.startPos)]);else if(t in this._fields){const r=this._constructors[this._fields[t][0].constructorName].startPos;wr(e.name.startPos,e.name.endPos,"function-and-field-cannot-have-the-same-name",[t,_r(e.startPos),_r(r)])}const r=[];for(const t of e.parameters)r.push(t.value);this._functions[t]=e,this._functionParameters[t]=r}defType(e){const t=e.typeName.value;t in this._types&&wr(e.typeName.startPos,e.typeName.endPos,"type-already-defined",[t,_r(this._types[t].startPos),_r(e.startPos)]),this._types[t]=e;const r=[];for(const s of e.constructorDeclarations)this._declareConstructor(t,s),r.push(s.constructorName.value);this._typeConstructors[t]=r}_declareConstructor(e,t){const r=t.constructorName.value;r in this._constructors&&wr(t.constructorName.startPos,t.constructorName.endPos,"constructor-already-defined",[r,_r(this._constructors[r].startPos),_r(t.startPos)]),this._constructors[r]=t,this._constructorType[r]=e;const s={},n=[];let o=0;for(const i of t.fieldNames)i.value in s&&wr(i.startPos,i.endPos,"repeated-field-name",[r,i.value]),s[i.value]=!0,n.push(i.value),this._declareField(i.startPos,i.endPos,e,r,i.value,o),o++;this._constructorFields[r]=n}_declareField(e,t,r,s,n,o){n in this._functions&&wr(e,t,"function-and-field-cannot-have-the-same-name",[n,_r(this._functions[n].startPos),_r(e)]),n in this._fields||(this._fields[n]=[]),this._fields[n].push(new vr(r,s,o))}addNewLocalName(e,t){e.value in this._localNames&&wr(e.startPos,e.endPos,"local-name-conflict",[e.value,mr(Symbol.keyFor(this._localNames[e.value].category)),_r(this._localNames[e.value].position),mr(Symbol.keyFor(t)),_r(e.startPos)]),this.setLocalName(e,t)}setLocalName(e,t){e.value in this._localNames&&this._localNames[e.value].category!==t&&wr(e.startPos,e.endPos,"local-name-conflict",[e.value,mr(Symbol.keyFor(this._localNames[e.value].category)),_r(this._localNames[e.value].position),mr(Symbol.keyFor(t)),_r(e.startPos)]),this._localNames[e.value]=new Er(t,e.startPos)}removeLocalName(e){delete this._localNames[e.value]}exitScope(){this._localNames={}}getAttributes(e){return"program"===e&&void 0!==this._program?this._program.attributes:e in this._procedures?this._procedures[e].attributes:e in this._functions?this._functions[e].attributes:e in this._types?this._types[e].attributes:{}}}class Cr{constructor(){this._callGraph={}}callCycle(e){return this._visitNode(e),this._findCallCycle()}_addEdge(e,t){e in this._callGraph||(this._callGraph[e]={}),t.value in this._callGraph[e]||(this._callGraph[e][t.value]=t)}_visitNode(e){void 0===e||e instanceof Ce||(e instanceof Array?this._visitNodes(e):this._visitTaggedNode(e))}_visitNodes(e){for(const t of e)this._visitNode(t)}_visitTaggedNode(e){switch(e.tag){case Oe:case ke:this._visitProgramDefinition();break;case Ie:case Re:this._visitRoutineDefinition(e);break;case $e:this._visitProcedureCall(e);break;case it:this._visitFunctionCall(e)}this._visitNodes(e.children)}_visitProgramDefinition(){this._currentRoutine="program"}_visitRoutineDefinition(e){this._currentRoutine=e.name.value}_visitProcedureCall(e){this._addEdge(this._currentRoutine,e.procedureName)}_visitFunctionCall(e){this._addEdge(this._currentRoutine,e.functionName)}_findCallCycle(){const e={},t={};for(const r in this._callGraph){e[r]=!0,t[r]=!0;const s=this._findCallCycleFrom(e,t,[],r);if(void 0!==s)return s;delete t[r]}}_findCallCycleFrom(e,t,r,s){for(const n in this._callGraph[s]){if(r.push({caller:s,callee:n,location:this._callGraph[s][n]}),n in t){for(;r[0].caller!==n;)r.shift();return r.push(),r}if(!(n in e)){e[n]=!0,t[n]=!0;const s=this._findCallCycleFrom(e,t,r,n);if(void 0!==s)return s;delete t[n]}r.pop()}}}const Nr=e=>e.tag===Ae&&e.statements.length>0&&e.statements.slice(-1)[0].tag===Me;class Or{constructor(e){this._symtable=e,this._enabledLinterChecks={"source-should-have-a-program-definition":!0,"procedure-should-not-have-return":!0,"function-should-have-return":!0,"return-statement-not-allowed-here":!0,"wildcard-pattern-should-be-last":!0,"variable-pattern-should-be-last":!0,"structure-pattern-repeats-constructor":!0,"structure-pattern-repeats-tuple-arity":!0,"structure-pattern-repeats-timeout":!0,"pattern-does-not-match-type":!0,"patterns-in-interactive-program-must-be-events":!0,"patterns-in-interactive-program-cannot-be-variables":!0,"patterns-in-switch-must-not-be-events":!0,"patterns-in-foreach-must-not-be-events":!0,"repeated-variable-in-tuple-assignment":!0,"constructor-used-as-procedure":!0,"undefined-procedure":!0,"procedure-arity-mismatch":!0,"numeric-pattern-repeats-number":!0,"structure-pattern-arity-mismatch":!0,"structure-construction-repeated-field":!0,"structure-construction-invalid-field":!0,"structure-construction-missing-field":!0,"structure-construction-cannot-be-an-event":!0,"undefined-function":!0,"function-arity-mismatch":!0,"type-used-as-constructor":!0,"procedure-used-as-constructor":!0,"undeclared-constructor":!0,"forbidden-extension-destructuring-foreach":!0,"forbidden-extension-allow-recursion":!0}}lint(e){return this._lintMain(e),this._symtable}_ensureLintCheckExists(e){if(!(e in this._enabledLinterChecks))throw Error('Linter check "'+e+'" does not exist.')}enableCheck(e,t){this._ensureLintCheckExists(e),this._enabledLinterChecks[e]=t}_lintCheck(e,t,r,s){this._ensureLintCheckExists(r),this._enabledLinterChecks[r]&&function(e,t,r,s){throw new br(e,t,r,s)}(e,t,r,s)}_lintMain(e){for(const t of e.definitions)this._addDefinitionToSymbolTable(t);e.definitions.length>0&&void 0===this._symtable.program&&this._lintCheck(e.startPos,e.endPos,"source-should-have-a-program-definition",[]);for(const t of e.definitions)this._lintDefinition(t);this._disableRecursion(e)}_addDefinitionToSymbolTable(e){switch(e.tag){case Oe:return this._symtable.defProgram(e);case ke:return this._symtable.defInteractiveProgram(e);case Ie:return this._symtable.defProcedure(e);case Re:return this._symtable.defFunction(e);case Le:return this._symtable.defType(e);default:throw Error("Unknown definition: "+Symbol.keyFor(e.tag))}}_lintDefinition(e){switch(e.tag){case Oe:return this._lintDefProgram(e);case ke:return this._lintDefInteractiveProgram(e);case Ie:return this._lintDefProcedure(e);case Re:return this._lintDefFunction(e);case Le:return this._lintDefType();default:throw Error("Linter: Definition not implemented: "+Symbol.keyFor(e.tag))}}_lintDefProgram(e){this._lintStmtBlock(e.body,!0),this._symtable.exitScope()}_lintDefInteractiveProgram(e){this._lintSwitchBranches(e.branches,!0)}_lintDefProcedure(e){Nr(e.body)&&this._lintCheck(e.startPos,e.endPos,"procedure-should-not-have-return",[e.name.value]);for(const t of e.parameters)this._symtable.addNewLocalName(t,Sr);this._lintStmtBlock(e.body,!1),this._symtable.exitScope()}_lintDefFunction(e){Nr(e.body)||this._lintCheck(e.startPos,e.endPos,"function-should-have-return",[e.name.value]);for(const t of e.parameters)this._symtable.addNewLocalName(t,Sr);this._lintStmtBlock(e.body,!0),this._symtable.exitScope()}_lintDefType(){}_lintStatement(e){switch(e.tag){case Ae:return this._lintStmtBlock(e,!1);case Me:return this._lintStmtReturn(e);case Fe:return this._lintStmtIf(e);case Be:return this._lintStmtRepeat(e);case De:return this._lintStmtForeach(e);case Ve:return this._lintStmtWhile(e);case He:return this._lintStmtSwitch(e);case Ge:return this._lintStmtAssignVariable(e);case Ue:return this._lintStmtAssignTuple(e);case $e:return this._lintStmtProcedureCall(e);default:throw Error("Linter: Statement not implemented: "+Symbol.keyFor(e.tag))}}_lintStmtBlock(e,t){let r=0;for(const s of e.statements){t&&r===e.statements.length-1||s.tag!==Me||this._lintCheck(s.startPos,s.endPos,"return-statement-not-allowed-here",[]),this._lintStatement(s),r++}}_lintStmtReturn(e){this._lintExpression(e.result)}_lintStmtIf(e){this._lintExpression(e.condition),this._lintStatement(e.thenBlock),void 0!==e.elseBlock&&this._lintStatement(e.elseBlock)}_lintStmtRepeat(e){this._lintExpression(e.times),this._lintStatement(e.body)}_lintStmtForeach(e){this._lintStmtForeachPattern(e.pattern),this._lintExpression(e.range);for(const t of e.pattern.boundVariables)this._symtable.addNewLocalName(t,yr);this._lintStatement(e.body);for(const t of e.pattern.boundVariables)this._symtable.removeLocalName(t)}_lintStmtForeachPattern(e){e.tag!==We&&this._lintCheck(e.startPos,e.endPos,"forbidden-extension-destructuring-foreach",[]),this._lintPattern(e);this._patternType(e)===mr("TYPE:Event")&&this._lintCheck(e.startPos,e.endPos,"patterns-in-foreach-must-not-be-events",[])}_lintStmtWhile(e){this._lintExpression(e.condition),this._lintStatement(e.body)}_lintStmtSwitch(e){this._lintExpression(e.subject),this._lintSwitchBranches(e.branches,!1)}_lintSwitchBranches(e,t){this._lintBranches(e,t,!1)}_lintBranches(e,t,r){for(const t of e)this._lintPattern(t.pattern);this._branchesCheckWildcardAndVariable(e),this._branchesCheckNoRepeats(e),this._branchesCheckCompatible(e),t?this._branchesCheckTypeEvent(e):this._branchesCheckTypeNotEvent(e);for(const t of e)this._lintBranchBody(t,r)}_branchesCheckWildcardAndVariable(e){let t=0;const r=e.length;for(const s of e)s.pattern.tag===je&&t!==r-1&&this._lintCheck(s.pattern.startPos,s.pattern.endPos,"wildcard-pattern-should-be-last",[]),s.pattern.tag===We&&t!==r-1&&this._lintCheck(s.pattern.startPos,s.pattern.endPos,"variable-pattern-should-be-last",[s.pattern.variableName.value]),t++}_branchesCheckNoRepeats(e){const t={},r={},s={};let n=!1;for(const o of e)switch(o.pattern.tag){case je:case We:break;case qe:{const e=o.pattern.number.value;e in t&&this._lintCheck(o.pattern.startPos,o.pattern.endPos,"numeric-pattern-repeats-number",[e]),t[e]=!0;break}case ze:{const e=o.pattern.constructorName.value;e in r&&this._lintCheck(o.pattern.startPos,o.pattern.endPos,"structure-pattern-repeats-constructor",[e]),r[e]=!0;break}case Ye:{const e=o.pattern.boundVariables.length;e in s&&this._lintCheck(o.pattern.startPos,o.pattern.endPos,"structure-pattern-repeats-tuple-arity",[e]),s[e]=!0;break}case Je:n&&this._lintCheck(o.pattern.startPos,o.pattern.endPos,"structure-pattern-repeats-timeout",[]),n=!0;break;default:throw Error('Linter: pattern "'+Symbol.keyFor(o.pattern.tag)+'" not implemented.')}}_branchesCheckCompatible(e){let t;for(const r of e){const e=this._patternType(r.pattern);void 0===t?t=e:void 0!==e&&t!==e&&this._lintCheck(r.pattern.startPos,r.pattern.endPos,"pattern-does-not-match-type",[dr("<pattern-type>")(t),dr("<pattern-type>")(e)])}}_branchesCheckTypeEvent(e){for(const t of e){const e=this._patternType(t.pattern);void 0!==e&&e!==mr("TYPE:Event")&&this._lintCheck(t.pattern.startPos,t.pattern.endPos,"patterns-in-interactive-program-must-be-events",[]),t.pattern.tag===We&&this._lintCheck(t.pattern.startPos,t.pattern.endPos,"patterns-in-interactive-program-cannot-be-variables",[])}}_branchesCheckTypeNotEvent(e){for(const t of e){this._patternType(t.pattern)===mr("TYPE:Event")&&this._lintCheck(t.pattern.startPos,t.pattern.endPos,"patterns-in-switch-must-not-be-events",[])}}_lintBranchBody(e,t){for(const t of e.pattern.boundVariables)this._symtable.addNewLocalName(t,Sr);t?this._lintExpression(e.body):this._lintStatement(e.body);for(const t of e.pattern.boundVariables)this._symtable.removeLocalName(t)}_patternType(e){switch(e.tag){case je:case We:return;case qe:return mr("TYPE:Integer");case ze:return this._symtable.constructorType(e.constructorName.value);case Ye:return"_TUPLE_"+e.boundVariables.length.toString();case Je:return mr("TYPE:Event");default:throw Error('Linter: pattern "'+Symbol.keyFor(e.tag)+'" not implemented.')}}_lintStmtAssignVariable(e){this._symtable.setLocalName(e.variable,Tr),this._lintExpression(e.value)}_lintStmtAssignTuple(e){const t={};for(const r of e.variables)this._symtable.setLocalName(r,Tr),r.value in t&&this._lintCheck(r.startPos,r.endPos,"repeated-variable-in-tuple-assignment",[r.value]),t[r.value]=!0;this._lintExpression(e.value)}_lintStmtProcedureCall(e){const t=e.procedureName.value;this._symtable.isProcedure(t)||(this._symtable.isConstructor(t)?this._lintCheck(e.startPos,e.endPos,"constructor-used-as-procedure",[t,this._symtable.constructorType(t)]):this._lintCheck(e.startPos,e.endPos,"undefined-procedure",[t]));const r=this._symtable.procedureParameters(t).length,s=e.args.length;r!==s&&this._lintCheck(e.startPos,e.endPos,"procedure-arity-mismatch",[t,r,s]);for(const t of e.args)this._lintExpression(t)}_lintPattern(e){switch(e.tag){case je:return this._lintPatternWildcard();case We:return this._lintPatternVariable();case qe:return this._lintPatternNumber();case ze:return this._lintPatternStructure(e);case Ye:return this._lintPatternTuple();case Je:return this._lintPatternTimeout();default:throw Error('Linter: pattern "'+Symbol.keyFor(e.tag)+'" not implemented.')}}_lintPatternWildcard(){}_lintPatternVariable(){}_lintPatternNumber(){}_lintPatternStructure(e){const t=e.constructorName.value;if(!this._symtable.isConstructor(t))return void this._failExpectedConstructorButGot(e.startPos,e.endPos,t);const r=this._symtable.constructorFields(t).length,s=e.boundVariables.length;s>0&&r!==s&&this._lintCheck(e.startPos,e.endPos,"structure-pattern-arity-mismatch",[t,r,s])}_lintPatternTuple(){}_lintPatternTimeout(){}_lintExpression(e){switch(e.tag){case Ke:return this._lintExprVariable();case Qe:return this._lintExprConstantNumber();case Ze:return this._lintExprConstantString();case Xe:return this._lintExprChoose(e);case et:return this._lintExprMatching(e);case tt:return this._lintExprList(e);case rt:return this._lintExprRange(e);case st:return this._lintExprTuple(e);case nt:return this._lintExprStructure(e);case ot:return this._lintExprStructureUpdate(e);case it:return this._lintExprFunctionCall(e);default:throw Error("Linter: Expression not implemented: "+Symbol.keyFor(e.tag))}}_lintExprVariable(){}_lintExprConstantNumber(){}_lintExprConstantString(){}_lintExprChoose(e){this._lintExpression(e.condition),this._lintExpression(e.trueExpr),this._lintExpression(e.falseExpr)}_lintExprMatching(e){this._lintExpression(e.subject),this._lintMatchingBranches(e.branches)}_lintMatchingBranches(e){this._lintBranches(e,!1,!0)}_lintExprList(e){for(const t of e.elements)this._lintExpression(t)}_lintExprRange(e){this._lintExpression(e.first),void 0!==e.second&&this._lintExpression(e.second),this._lintExpression(e.last)}_lintExprTuple(e){for(const t of e.elements)this._lintExpression(t)}_lintExprStructure(e){this._lintExprStructureOrUpdate(e,void 0)}_lintExprStructureUpdate(e){this._lintExprStructureOrUpdate(e,e.original)}_lintExprStructureOrUpdate(e,t){const r=e.constructorName.value;if(this._symtable.isConstructor(r)){this._checkStructureTypeNotEvent(r,e),this._checkStructureNoRepeatedFields(r,e),this._checkStructureBindingsCorrect(r,e),void 0===t&&this._checkStructureBindingsComplete(r,e),void 0!==t&&this._lintExpression(t);for(const t of e.fieldBindings)this._lintExpression(t.value)}else this._failExpectedConstructorButGot(e.startPos,e.endPos,r)}_checkStructureNoRepeatedFields(e,t){const r=t.fieldNames(),s={};for(const n of r)n in s&&this._lintCheck(t.startPos,t.endPos,"structure-construction-repeated-field",[e,n]),s[n]=!0}_checkStructureBindingsCorrect(e,t){const r=t.fieldNames(),s=this._symtable.constructorFields(e);for(const n of r)-1===s.indexOf(n)&&this._lintCheck(t.startPos,t.endPos,"structure-construction-invalid-field",[e,n])}_checkStructureBindingsComplete(e,t){const r=t.fieldNames(),s=this._symtable.constructorFields(e);for(const n of s)-1===r.indexOf(n)&&this._lintCheck(t.startPos,t.endPos,"structure-construction-missing-field",[e,n])}_checkStructureTypeNotEvent(e,t){this._symtable.constructorType(e)===mr("TYPE:Event")&&this._lintCheck(t.startPos,t.endPos,"structure-construction-cannot-be-an-event",[e])}_lintExprFunctionCall(e){const t=e.functionName.value;let r;this._symtable.isFunction(t)||this._symtable.isField(t)||this._lintCheck(e.startPos,e.endPos,"undefined-function",[t]),r=this._symtable.isFunction(t)?this._symtable.functionParameters(t).length:1;const s=e.args.length;r!==s&&this._lintCheck(e.startPos,e.endPos,"function-arity-mismatch",[t,r,s]);for(const t of e.args)this._lintExpression(t)}_disableRecursion(e){if(this._enabledLinterChecks["forbidden-extension-allow-recursion"]){const t=(new Cr).callCycle(e);void 0!==t&&this._lintCheck(t[0].location.startPos,t[0].location.endPos,"forbidden-extension-allow-recursion",[t])}}_failExpectedConstructorButGot(e,t,r){this._symtable.isType(r)?this._lintCheck(e,t,"type-used-as-constructor",[r,this._symtable.typeConstructors(r)]):this._symtable.isProcedure(r)?this._lintCheck(e,t,"procedure-used-as-constructor",[r]):this._lintCheck(e,t,"undeclared-constructor",[r])}}const kr=e=>e>="0"&&e<="9",Ir=e=>e.toUpperCase()!==e.toLowerCase(),Rr=e=>Ir(e)||kr(e)||"_"===e||"'"===e,Lr={program:T,interactive:S,procedure:y,function:E,return:w,if:x,then:C,elseif:N,else:O,choose:k,when:I,otherwise:R,repeat:F,foreach:B,in:D,while:V,switch:H,to:G,matching:L,select:A,on:M,let:U,not:$,div:j,mod:W,type:q,is:z,record:Y,variant:J,case:K,field:Q,_:Z},Ar=mr("CONS:TIMEOUT");Lr["string"==typeof Ar?Ar:""]=X;const Mr=[{symbol:"(",tag:ee},{symbol:")",tag:te},{symbol:"{",tag:re},{symbol:"}",tag:se},{symbol:"[",tag:ne},{symbol:"]",tag:oe},{symbol:",",tag:ie},{symbol:";",tag:ae},{symbol:"...",tag:ce},{symbol:"..",tag:ue},{symbol:":=",tag:me},{symbol:"&&",tag:ve},{symbol:"||",tag:Te},{symbol:"<-",tag:le},{symbol:"|",tag:he},{symbol:"->",tag:pe},{symbol:"==",tag:de},{symbol:"/=",tag:_e},{symbol:"<=",tag:ge},{symbol:">=",tag:fe},{symbol:"<",tag:be},{symbol:">",tag:Pe},{symbol:"++",tag:Se},{symbol:"+",tag:ye},{symbol:"-",tag:Ee},{symbol:"*",tag:we},{symbol:"^",tag:xe}],Fr=["DestructuringForeach","AllowRecursion"];function Br(e,t,r,s){throw new br(e,t,r,s)}const Dr={"(":")","[":"]","{":"}"};class Vr{constructor(e){this._multifileReader=new _(e),this._reader=this._multifileReader.readCurrentFile(),this._warnings=[],this._delimiterStack=[],this._pendingAttributes={},this._languageOptions=[]}nextToken(){if(!this._findNextToken()){const e=new Ce(g,void 0,this._reader,this._reader);return this._checkBalancedDelimiters(e),e}if(kr(this._reader.peek())){const e=this._reader,r=this._readStringWhile(kr),s=this._reader;return(t=r).length>=0&&"0"===t[0]&&r.length>1&&Br(e,s,"numeric-constant-should-not-have-leading-zeroes",[]),new Ce(f,r,e,s)}if(!Rr(this._reader.peek()))return'"'===this._reader.peek()?this._readStringConstant():this._readSymbol();{const t=this._reader,r=this._readStringWhile(Rr),s=this._reader;if(r in Lr)return new Ce(Lr[r],r,t,s);if(e=r[0],Ir(e)&&e.toUpperCase()===e)return new Ce(P,r,t,s);if((e=>Ir(e)&&e.toLowerCase()===e)(r[0]))return new Ce(v,r,t,s);Br(t,s,"identifier-must-start-with-alphabetic-character",[])}var e,t}warnings(){return this._warnings}_findNextToken(){for(;this._ignoreWhitespaceAndComments(),this._reader.eof();){if(!this._multifileReader.moreFiles())return!1;this._multifileReader.nextFile(),this._reader=this._multifileReader.readCurrentFile()}return!0}_readStringWhile(e){const t=[];for(;!this._reader.eof()&&e(this._reader.peek());)t.push(this._reader.peek()),this._reader=this._reader.consumeCharacter();return t.join("")}_readStringConstant(){const e=this._reader,t=[];for(this._reader=this._reader.consumeCharacter();!this._reader.eof();){const r=this._reader.peek();if('"'===r)return this._reader=this._reader.consumeCharacter(),new Ce(b,t.join(""),e,this._reader);if("\\"===r){if(this._reader=this._reader.consumeCharacter(),this._reader.eof())break;const e=this._reader.peek();switch(this._reader=this._reader.consumeCharacter(),e){case"a":t.push("");break;case"b":t.push("\b");break;case"f":t.push("\f");break;case"n":t.push("\n");break;case"r":t.push("\r");break;case"t":t.push("\t");break;case"v":t.push("\v");break;default:t.push(e)}}else t.push(r),this._reader=this._reader.consumeCharacter()}Br(e,this._reader,"unclosed-string-constant",[])}_readSymbol(){for(const{symbol:e,tag:t}of Mr)if(this._reader.startsWith(e)){const r=this._reader;this._reader=this._reader.consumeString(e);const s=this._reader,n=new Ce(t,e,r,s);return this._checkBalancedDelimiters(n),n}Br(this._reader,this._reader,"unknown-token",[this._reader.peek()])}_ignoreWhitespaceAndComments(){for(;this._ignoreWhitespace()||this._ignoreComments(););}_ignoreWhitespace(){return!this._reader.eof()&&(" "===(e=this._reader.peek())||"\t"===e||"\r"===e||"\n"===e)&&(this._reader=this._reader.consumeCharacter(),!0);var e}_ignoreComments(){if(this._startSingleLineComment())return this._ignoreSingleLineComment(),!0;if(this._reader.startsWith("/*@")){const e=this._reader;return this._evaluatePragma(e,this._readInvisiblePragma("/*","*/","@")),!0}return this._reader.startsWith("{-")?(this._ignoreMultilineComment("{-","-}"),!0):!!this._reader.startsWith("/*")&&(this._ignoreMultilineComment("/*","*/"),!0)}_startSingleLineComment(){return this._reader.startsWith("--")||this._reader.startsWith("//")||this._reader.startsWith("#")}_ignoreSingleLineComment(){for(;!this._reader.eof()&&(this._reader=this._reader.consumeCharacter(),"\n"!==this._reader.peek()););}_ignoreMultilineComment(e,t){let r=0;const s=this._reader;for(;!this._reader.eof();)if(this._reader.startsWith(e))this._reader=this._reader.consumeString(e),r++;else if(this._reader.startsWith(t)){if(this._reader=this._reader.consumeString(t),r--,0===r)return}else this._reader=this._reader.consumeCharacter();Br(s,this._reader,"unclosed-multiline-comment",[])}_readInvisiblePragma(e,t,r){const s=[],n=this._reader;for(this._reader=this._reader.consumeInvisibleString(e),this._reader=this._reader.consumeInvisibleString(r);!this._reader.eof();)if(s.push(this._readInvisibleStringUntilDelimiter(r)),this._reader=this._reader.consumeInvisibleString(r),this._reader.startsWith(t))return this._reader=this._reader.consumeInvisibleString(t),s;Br(n,this._reader,"unclosed-multiline-comment",[])}_readInvisibleStringUntilDelimiter(e){const t=this._reader,r=[];for(;!this._reader.eof();){if(this._reader.peek()===e)return r.join("");r.push(this._reader.peek()),this._reader=this._reader.consumeInvisibleCharacter()}Br(t,this._reader,"unclosed-multiline-comment",[])}_evaluatePragma(e,t){if(0===t.length)this._emitWarning(e,this._reader,"empty-pragma",[]);else if("BEGIN_REGION"===t[0]){const e=t[1];this._reader=this._reader.beginRegion(e)}else if("END_REGION"===t[0])this._reader=this._reader.endRegion();else if("ATTRIBUTE"===t[0]&&t.length>=2){const e=t[1],r=t.slice(2,t.length).join("@");this.setAttribute(e,r)}else if("LANGUAGE"===t[0]&&2===t.length){const e=t[1];this.addLanguageOption(e)}else this._emitWarning(e,this._reader,"unknown-pragma",[t[0]])}_emitWarning(e,t,r,s){this._warnings.push(new fr(e,t,r,s))}_checkBalancedDelimiters(e){if(e.tag===g&&this._delimiterStack.length>0){const e=this._delimiterStack.pop();Br(e.startPos,e.endPos,"unmatched-opening-delimiter",[e.value])}else if(e.tag===ee||e.tag===re||e.tag===ne)this._delimiterStack.push(e);else if(e.tag===te||e.tag===se||e.tag===oe){0===this._delimiterStack.length&&Br(e.startPos,e.endPos,"unmatched-closing-delimiter",[e.value]);const t=this._delimiterStack.pop();Dr[t.value]!==e.value&&Br(t.startPos,t.endPos,"unmatched-opening-delimiter",[t.value])}}getPendingAttributes(){const e=this._pendingAttributes;return this._pendingAttributes={},e}setAttribute(e,t){this._pendingAttributes[e]=t}getLanguageOptions(){return this._languageOptions}addLanguageOption(e){-1!==Fr.indexOf(e)?this._languageOptions.push(e):Br(this._reader,this._reader,"unknown-language-option",[e])}}const Hr=Symbol.for("Infix"),Gr=Symbol.for("InfixL"),Ur=Symbol.for("InfixR"),$r=Symbol.for("Prefix");class jr{constructor(e,t){this._fixity=e,this._operators=t}get fixity(){return this._fixity}isOperator(e){return Symbol.keyFor(e.tag)in this._operators}functionName(e){return new Ce(v,this._operators[Symbol.keyFor(e.tag)],e.startPos,e.endPos)}}const Wr=[new jr(Ur,{T_OR:"||"}),new jr(Ur,{T_AND:"&&"}),new jr($r,{T_NOT:"not"}),new jr(Hr,{T_EQ:"==",T_NE:"/=",T_LE:"<=",T_GE:">=",T_LT:"<",T_GT:">"}),new jr(Gr,{T_CONCAT:"++"}),new jr(Gr,{T_PLUS:"+",T_MINUS:"-"}),new jr(Gr,{T_TIMES:"*"}),new jr(Gr,{T_DIV:"div",T_MOD:"mod"}),new jr(Ur,{T_POW:"^"}),new jr($r,{T_MINUS:"-(unary)"})];function qr(e,t,r,s){throw new br(e,t,r,s)}class zr{constructor(e){this._lexer=new Vr(e),this._nextToken()}parse(){const e=[];for(;this._currentToken.tag!==g;)e.push(this._parseDefinition());return new _t(e)}getLanguageOptions(){return this._lexer.getLanguageOptions()}_parseDefinition(){switch(this._currentToken.tag){case T:return this._parseDefProgram();case S:return this._parseDefInteractiveProgram();case y:return this._parseDefProcedure();case E:return this._parseDefFunction();case q:return this._parseDefType();default:qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("definition"),mr(Symbol.keyFor(this._currentToken.tag))])}}_parseDefProgram(){const e=this._currentToken.startPos;this._match(T);const t=this._lexer.getPendingAttributes(),r=this._parseStmtBlock(),s=new gt(r);return s.startPos=e,s.endPos=r.endPos,s.attributes=t,s}_parseDefInteractiveProgram(){const e=this._currentToken.startPos;this._match(S),this._match(T);const t=this._lexer.getPendingAttributes();this._match(re);const r=this._parseSwitchBranches(),s=this._currentToken.startPos;this._match(se);const n=new bt(r);return n.startPos=e,n.endPos=s,n.attributes=t,n}_parseDefProcedure(){const e=this._currentToken.startPos;this._match(y);const t=this._parseUpperid();this._match(ee);const r=this._parseLoweridSeq();this._match(te);const s=this._lexer.getPendingAttributes(),n=this._parseStmtBlock(),o=new Pt(t,r,n);return o.startPos=e,o.endPos=n.endPos,o.attributes=s,o}_parseDefFunction(){const e=this._currentToken.startPos;this._match(E);const t=this._currentToken;this._match(v),this._match(ee);const r=this._parseLoweridSeq();this._match(te);const s=this._lexer.getPendingAttributes(),n=this._parseStmtBlock(),o=new vt(t,r,n);return o.startPos=e,o.endPos=n.endPos,o.attributes=s,o}_parseDefType(){const e=this._currentToken.startPos;this._match(q);const t=this._parseUpperid();switch(this._match(z),this._currentToken.tag){case Y:return this._parseDefTypeRecord(e,t);case J:return this._parseDefTypeVariant(e,t);default:qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("<alternative>")([mr("T_RECORD"),mr("T_VARIANT")]),mr(Symbol.keyFor(this._currentToken.tag))])}}_parseDefTypeRecord(e,t){this._match(Y);const r=this._lexer.getPendingAttributes();this._match(re);const s=this._parseFieldNames(),n=this._currentToken.startPos;this._matchExpected(se,[Q,se]);const o=new Tt(t,[new Xt(t,s)]);return o.startPos=e,o.endPos=n,o.attributes=r,o}_parseDefTypeVariant(e,t){const r=[];this._match(J);const s=this._lexer.getPendingAttributes();for(this._match(re);this._currentToken.tag===K;)r.push(this._parseConstructorDeclaration());const n=this._currentToken.startPos;this._matchExpected(se,[K,se]);const o=new Tt(t,r);return o.startPos=e,o.endPos=n,o.attributes=s,o}_parseConstructorDeclaration(){const e=this._currentToken.startPos;this._match(K);const t=this._parseUpperid();this._match(re);const r=this._parseFieldNames(),s=this._currentToken.startPos;this._matchExpected(se,[Q,se]);const n=new Xt(t,r);return n.startPos=e,n.endPos=s,n}_parseFieldNames(){const e=[];for(;this._currentToken.tag===Q;)this._match(Q),e.push(this._parseLowerid());return e}_parseStatement(){const e=this._parsePureStatement();return this._currentToken.tag===ae&&this._match(ae),e}_parsePureStatement(){switch(this._currentToken.tag){case ce:return this._parseStmtEllipsis();case w:return this._parseStmtReturn();case x:return this._parseStmtIf(!0);case F:return this._parseStmtRepeat();case B:return this._parseStmtForeach();case V:return this._parseStmtWhile();case H:return this._parseStmtSwitch();case U:return this._parseStmtLet();case re:return this._parseStmtBlock();case v:return this._parseStmtAssignVariable();case P:return this._parseStmtProcedureCall();case ee:return void qr(this._currentToken.startPos,this._currentToken.endPos,"obsolete-tuple-assignment",[]);default:qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("statement"),mr(Symbol.keyFor(this._currentToken.tag))])}}_parseStmtBlock(){const e=this._currentToken.startPos,t=[];for(this._match(re);this._currentToken.tag!==se;)t.push(this._parseStatement()),this._currentToken.tag===ae&&this._match(ae);const r=this._currentToken.startPos;this._match(se);const s=new St(t);return s.startPos=e,s.endPos=r,s}_parseStmtEllipsis(){const e=this._currentToken.startPos;this._match(ce);const t=new At(new Ce(P,mr("PRIM:BOOM"),e,e),[new $t(new Ce(b,mr("errmsg:ellipsis")))]);return t.startPos=e,t.endPos=this._currentToken.startPos,t}_parseStmtReturn(){const e=this._currentToken.startPos;this._match(w);const t=this._parseExprTuple(!1),r=new yt(t);return r.startPos=e,r.endPos=t.endPos,r}_parseStmtIf(e){const t=this._currentToken.startPos;e&&this._match(x),this._match(ee);const r=this._parseExpression();this._match(te),this._currentToken.tag===C&&this._match(C);const s=this._parseStmtBlock();let n,o;this._currentToken.tag===N?(this._match(N),o=this._parseStmtIf(!1),n=o.endPos):this._currentToken.tag===O?(this._match(O),o=this._parseStmtBlock(),n=o.endPos):(o=void 0,n=s.endPos);const i=new Et(r,s,o);return i.startPos=t,i.endPos=n,i}_parseStmtRepeat(){const e=this._currentToken.startPos;this._match(F),this._match(ee);const t=this._parseExpression();this._match(te);const r=this._parseStmtBlock(),s=new wt(t,r);return s.startPos=e,s.endPos=r.endPos,s}_parseStmtForeach(){const e=this._currentToken.startPos;this._match(B);const t=this._parsePattern();this._match(D);const r=this._parseExpression(),s=this._parseStmtBlock(),n=new Ct(t,r,s);return n.startPos=e,n.endPos=s.endPos,n}_parseStmtWhile(){const e=this._currentToken.startPos;this._match(V),this._match(ee);const t=this._parseExpression();this._match(te);const r=this._parseStmtBlock(),s=new Nt(t,r);return s.startPos=e,s.endPos=r.endPos,s}_parseStmtSwitch(){const e=this._currentToken.startPos;this._match(H),this._match(ee);const t=this._parseExpression();this._match(te),this._currentToken.tag===G&&this._match(G),this._match(re);const r=this._parseSwitchBranches(),s=this._currentToken.startPos;this._match(se);const n=new Ot(t,r);return n.startPos=e,n.endPos=s,n}_parseStmtLet(){const e=this._currentToken.startPos;let t;return this._match(U),this._currentToken.tag===v?t=this._parseStmtAssignVariable():this._currentToken.tag===ee?t=this._parseStmtAssignTuple():qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("<alternative>")(mr("T_LOWERID"),mr("T_LPAREN")),mr(Symbol.keyFor(this._currentToken.tag))]),t.startPos=e,t}_parseStmtAssignVariable(){const e=this._parseLowerid();this._match(me);const t=this._parseExpression(),r=new Rt(e,t);return r.startPos=e.startPos,r.endPos=t.endPos,r}_parseStmtAssignTuple(){const e=this._currentToken.startPos;this._match(ee);const t=this._parseLoweridSeq();1===t.length&&qr(e,this._currentToken.endPos,"assignment-tuple-cannot-be-singleton",[]),this._match(te),this._match(me);const r=this._parseExpression(),s=new Lt(t,r);return s.startPos=e,s.endPos=r.endPos,s}_parseStmtProcedureCall(){const e=this._parseUpperid();this._match(ee);const t=this._parseDelimitedSeq(te,ie,(()=>this._parseExpression())),r=this._currentToken.startPos;this._match(te);const s=new At(e,t);return s.startPos=e.startPos,s.endPos=r,s}_parsePattern(){switch(this._currentToken.tag){case Z:return this._parsePatternWildcard();case v:return this._parsePatternVariable();case f:case Ee:return this._parsePatternNumber();case P:return this._parsePatternStructure();case ee:return this._parsePatternTuple();case X:return this._parsePatternTimeout();default:qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("pattern"),mr(Symbol.keyFor(this._currentToken.tag))])}}_parsePatternWildcard(){const e=this._currentToken.startPos;this._match(Z);const t=new Mt,r=e;return t.startPos=e,t.endPos=r,t}_parsePatternVariable(){const e=this._currentToken.startPos,t=this._parseLowerid(),r=new Ft(t);return r.startPos=e,r.endPos=t.endPos,r}_parsePatternNumber(){const e=this._currentToken.startPos;let t="";this._currentToken.tag===Ee&&(this._match(Ee),t="-");let r=this._currentToken;this._match(f);const s=t+r.value;"-0"===s&&qr(e,r.endPos,"pattern-number-cannot-be-negative-zero",[]),r=new Ce(f,s,r.startPos,r.endPos);const n=new Bt(r);return n.startPos=e,n.endPos=r.endPos,n}_parsePatternStructure(){const e=this._currentToken.startPos;let t=this._currentToken.startPos;const r=this._parseUpperid();let s;this._currentToken.tag===ee?(this._match(ee),s=this._parseLoweridSeq(),t=this._currentToken.startPos,this._match(te)):s=[];const n=new Dt(r,s);return n.startPos=e,n.endPos=t,n}_parsePatternTuple(){const e=this._currentToken.startPos;this._match(ee);const t=this._parseLoweridSeq();1===t.length&&qr(e,this._currentToken.endPos,"pattern-tuple-cannot-be-singleton",[]);const r=this._currentToken.startPos;this._match(te);const s=new Vt(t);return s.startPos=e,s.endPos=r,s}_parsePatternTimeout(){const e=this._currentToken.startPos;this._match(X),this._match(ee);const t=this._currentToken;this._match(f);const r=this._currentToken.startPos;this._match(te);const s=new Ht(t);return s.startPos=e,s.endPos=r,s}_parseExpression(){return this._parseExprOperator(0)}_parseExprOperator(e){if(e===Wr.length)return this._parseExprAtom();switch(Wr[e].fixity){case Hr:return this._parseExprOperatorInfix(e);case Gr:return this._parseExprOperatorInfixL(e);case Ur:return this._parseExprOperatorInfixR(e);case $r:return this._parseExprOperatorPrefix(e);default:throw Error("Invalid operator.")}}_parseExprOperatorInfix(e){const t=this._parseExprOperator(e+1);if(Wr[e].isOperator(this._currentToken)){const r=this._currentToken;this._nextToken();const s=this._parseExprOperator(e+1);Wr[e].isOperator(this._currentToken)&&qr(this._currentToken.startPos,this._currentToken.endPos,"operators-are-not-associative",[mr(Symbol.keyFor(r.tag)),mr(Symbol.keyFor(this._currentToken.tag))]);const n=new Qt(Wr[e].functionName(r),[t,s]);return n.startPos=t.startPos,n.endPos=s.endPos,n}return t}_parseExprOperatorInfixL(e){let t=this._parseExprOperator(e+1);for(;Wr[e].isOperator(this._currentToken);){const r=this._currentToken;this._nextToken();const s=this._parseExprOperator(e+1),n=new Qt(Wr[e].functionName(r),[t,s]);n.startPos=t.startPos,n.endPos=s.endPos,t=n}return t}_parseExprOperatorInfixR(e){const t=this._parseExprOperator(e+1);if(Wr[e].isOperator(this._currentToken)){const r=this._currentToken;this._nextToken();const s=this._parseExprOperator(e),n=new Qt(Wr[e].functionName(r),[t,s]);return n.startPos=t.startPos,n.endPos=s.endPos,n}return t}_parseExprOperatorPrefix(e){if(Wr[e].isOperator(this._currentToken)){const t=this._currentToken;this._nextToken();const r=this._parseExprOperator(e),s=new Qt(Wr[e].functionName(t),[r]);return s.startPos=t.startPos,s.endPos=r.endPos,s}return this._parseExprOperator(e+1)}_parseExprAtom(){switch(this._currentToken.tag){case ce:return this._parseExprEllipsis();case v:return this._parseExprVariableOrFunctionCall();case f:return this._parseExprConstantNumber();case b:return this._parseExprConstantString();case k:return this._parseExprChoose(!0);case L:return this._parseExprMatching();case P:return this._parseExprStructureOrStructureUpdate();case ee:return this._parseExprTuple(!0);case ne:return this._parseExprListOrRange();default:qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("expression"),mr(Symbol.keyFor(this._currentToken.tag))])}}_parseExprEllipsis(){const e=this._currentToken.startPos;this._match(ce);const t=new Qt(new Ce(v,mr("PRIM:boom"),e,e),[new $t(new Ce(b,mr("errmsg:ellipsis")))]);return t.startPos=e,t.endPos=this._currentToken.startPos,t}_parseExprVariableOrFunctionCall(){const e=this._parseLowerid();let t,r;if(this._currentToken.tag===ee){this._match(ee);const s=this._parseExpressionSeq(te);t=new Qt(e,s),r=this._currentToken.startPos,this._match(te)}else t=new Gt(e),r=e.endPos;return t.startPos=e.startPos,t.endPos=r,t}_parseExprConstantNumber(){const e=this._currentToken;this._match(f);const t=new Ut(e);return t.startPos=e.startPos,t.endPos=e.endPos,t}_parseExprConstantString(){const e=this._currentToken;this._match(b);const t=new $t(e);return t.startPos=e.startPos,t.endPos=e.endPos,t}_parseExprChoose(e){const t=this._currentToken.startPos;e&&this._match(k);const r=this._parseExpression();if(this._currentToken.tag===I){this._match(I),this._match(ee);const e=this._parseExpression();this._match(te);const s=this._parseExprChoose(!1),n=new jt(e,r,s);return n.startPos=t,n.endPos=s.endPos,n}{const e=this._currentToken.endPos;return this._match(R),r.startPos=t,r.endPos=e,r}}_parseExprMatching(){const e=this._currentToken.startPos;this._match(L),this._match(ee);const t=this._parseExpression();this._match(te),this._match(A);const r=this._parseMatchingBranches(),s=new Wt(t,r);return s.startPos=e,s}_parseExprStructureOrStructureUpdate(){const e=this._parseUpperid();if(this._currentToken.tag!==ee){const t=new Jt(e,[]);return t.startPos=e.startPos,t.endPos=e.endPos,t}if(this._match(ee),this._currentToken.tag===te){const t=new Jt(e,[]),r=this._currentToken.startPos;return this._match(te),t.startPos=e.startPos,t.endPos=r,t}const t=this._parseExpression();switch(this._currentToken.tag){case le:return t.tag!==Ke?void qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("T_PIPE"),mr("T_GETS")]):this._parseStructure(e,t.variableName);case he:return this._parseStructureUpdate(e,t);case ie:case te:return void qr(e.startPos,e.endPos,"expected-but-found",[mr("expression"),mr("procedure call")]);default:{let r;r=t.tag===Ke?mr("<alternative>")([mr("T_GETS"),mr("T_PIPE")]):mr("T_PIPE"),qr(e.startPos,e.endPos,"expected-but-found",[r,mr(Symbol.keyFor(this._currentToken.tag))])}}}_parseStructure(e,t){this._match(le);const r=this._parseExpression(),s=new Zt(t,r);s.startPos=t.startPos,s.endPos=r.endPos;const n=this._parseNonEmptyDelimitedSeq(te,ie,[s],(()=>this._parseFieldBinding())),o=this._currentToken.startPos;this._match(te);const i=new Jt(e,n);return i.startPos=e.startPos,i.endPos=o,i}_parseStructureUpdate(e,t){this._match(he);const r=this._parseDelimitedSeq(te,ie,(()=>this._parseFieldBinding())),s=this._currentToken.startPos;this._match(te);const n=new Kt(e,t,r);return n.startPos=e.startPos,n.endPos=s,n}_parseExprListOrRange(){const e=this._currentToken.startPos;if(this._match(ne),this._currentToken.tag===oe)return this._parseExprListRemainder(e,[]);const t=this._parseExpression();switch(this._currentToken.tag){case oe:return this._parseExprListRemainder(e,[t]);case ue:return this._parseExprRange(e,t);case ie:{this._match(ie);const r=this._parseExpression();switch(this._currentToken.tag){case oe:case ie:return this._parseExprListRemainder(e,[t,r]);case ue:return this._parseExprRange(e,t,r);default:return void qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("<alternative>")([mr("T_COMMA"),mr("T_RANGE"),mr("T_RBRACK")]),mr(Symbol.keyFor(this._currentToken.tag))])}}default:return void qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("<alternative>")([mr("T_COMMA"),mr("T_RANGE"),mr("T_RBRACK")]),mr(Symbol.keyFor(this._currentToken.tag))])}}_parseExprListRemainder(e,t){const r=this._parseNonEmptyDelimitedSeq(oe,ie,t,(()=>this._parseExpression())),s=this._currentToken.startPos;this._match(oe);const n=new qt(r);return n.startPos=e,n.endPos=s,n}_parseExprRange(e,t,r){this._match(ue);const s=this._parseExpression(),n=this._currentToken.startPos;this._match(oe);const o=new zt(t,r,s);return o.startPos=e,o.endPos=n,o}_parseExprTuple(e){const t=this._currentToken.startPos;this._match(ee);const r=this._parseExpressionSeq(te),s=this._currentToken.startPos;let n;return this._match(te),e||0!==r.length||qr(t,s,"return-tuple-cannot-be-empty",[]),n=1===r.length?r[0]:new Yt(r),n.startPos=t,n.endPos=s,n}_parseSwitchBranches(){const e=[];for(;this._currentToken.tag!==se;)e.push(this._parseSwitchBranch());return e}_parseSwitchBranch(){const e=this._parsePattern();this._match(pe);const t=this._parseStmtBlock(),r=new kt(e,t);return r.startPos=e.startPos,r.endPos=t.endPos,r}_parseMatchingBranches(){const e=[];for(;this._currentToken.tag!==R;)e.push(this._parseMatchingBranch());return this._match(R),e}_parseMatchingBranch(){const e=this._parseExpression();switch(this._currentToken.tag){case M:{this._match(M);const t=this._parsePattern(),r=new It(t,e);return r.startPos=e.startPos,r.endPos=t.endPos,r}case R:{const t=new Mt;t.startPos=this._currentToken.startPos,t.endPos=this._currentToken.endPos;const r=new It(t,e);return r.startPos=e.startPos,r.endPos=this._currentToken.endPos,r}default:qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("<alternative>")([mr("T_ON"),mr("T_OTHERWISE")]),mr(Symbol.keyFor(this._currentToken.tag))])}}_parseFieldBinding(){const e=this._parseLowerid();this._match(le);const t=this._parseExpression(),r=new Zt(e,t);return r.startPos=e.startPos,r.endPos=t.endPos,r}_nextToken(){this._currentToken=this._lexer.nextToken()}_match(e){this._currentToken.tag!==e&&qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr(Symbol.keyFor(e)),mr(Symbol.keyFor(this._currentToken.tag))]),this._nextToken()}_matchExpected(e,t){this._currentToken.tag!==e&&qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("<alternative>")(t.map((e=>mr(Symbol.keyFor(e))))),mr(Symbol.keyFor(this._currentToken.tag))]),this._nextToken()}_parseDelimitedSeq(e,t,r){if(this._currentToken.tag===e)return[];const s=r();return this._parseNonEmptyDelimitedSeq(e,t,[s],r)}_parseNonEmptyDelimitedSeq(e,t,r,s){const n=r;for(;this._currentToken.tag===t;)this._match(t),n.push(s());return this._currentToken.tag!==e&&qr(this._currentToken.startPos,this._currentToken.endPos,"expected-but-found",[mr("<alternative>")([mr(Symbol.keyFor(t)),mr(Symbol.keyFor(e))]),mr(Symbol.keyFor(this._currentToken.tag))]),n}_parseLowerid(){const e=this._currentToken;return this._match(v),e}_parseUpperid(){const e=this._currentToken;return this._match(P),e}_parseLoweridSeq(){return this._parseDelimitedSeq(te,ie,(()=>this._parseLowerid()))}_parseExpressionSeq(e){return this._parseDelimitedSeq(e,ie,(()=>this._parseExpression()))}}const Yr=Symbol.for("I_PushInteger"),Jr=Symbol.for("I_PushString"),Kr=Symbol.for("I_PushVariable"),Qr=Symbol.for("I_SetVariable"),Zr=Symbol.for("I_UnsetVariable"),Xr=Symbol.for("I_Label"),es=Symbol.for("I_Jump"),ts=Symbol.for("I_JumpIfFalse"),rs=Symbol.for("I_JumpIfStructure"),ss=Symbol.for("I_JumpIfTuple"),ns=Symbol.for("I_Call"),os=Symbol.for("I_Return"),is=Symbol.for("I_MakeTuple"),as=Symbol.for("I_MakeList"),cs=Symbol.for("I_MakeStructure"),us=Symbol.for("I_UpdateStructure"),ls=Symbol.for("I_ReadTupleComponent"),hs=Symbol.for("I_ReadStructureField"),ps=Symbol.for("I_ReadStructureFieldPop"),ms=Symbol.for("I_Add"),ds=Symbol.for("I_Dup"),_s=Symbol.for("I_Pop"),gs=Symbol.for("I_PrimitiveCall"),fs=Symbol.for("I_SaveState"),bs=Symbol.for("I_RestoreState"),Ps=Symbol.for("I_TypeCheck");class vs{constructor(e){this._instructions=e}toString(){const e=[];for(const t of this._instructions)e.push(t.toString());return e.join("\n")}produce(e){this._instructions.push(e)}at(e){if(e>=0&&e<this._instructions.length)return this._instructions[e];throw Error("Code: instruction pointer out of range.")}labelTargets(){const e={};for(let t=0;t<this._instructions.length;t++)if(this._instructions[t].opcode===Xr){const r=this._instructions[t].label;if(r in e)throw Error('Code: label "'+r+'" is repeated.');e[r]=t}return e}}function Ts(e){if(e instanceof Array){const t=[];for(const r of e)t.push(Ts(r));return"["+t.join(", ")+"]"}return e.toString()}class Ss{constructor(e,t){this._opcode=e,this._args=t,this._startPos=d,this._endPos=d}toString(){const e=Symbol.keyFor(this._opcode).substring(2),t=[];for(const e of this._args)t.push(Ts(e));return"  "+e+" "+t.join(", ")}get opcode(){return this._opcode}get args(){return this._args}set startPos(e){this._startPos=e}get startPos(){return this._startPos}set endPos(e){this._endPos=e}get endPos(){return this._endPos}}class ys extends Ss{constructor(e){super(Yr,[e])}get number(){return this._args[0]}}class Es extends Ss{constructor(e){super(Jr,[e])}get string(){return this._args[0]}}class ws extends Ss{constructor(e){super(Kr,[e])}get variableName(){return this._args[0]}}class xs extends Ss{constructor(e){super(Qr,[e])}get variableName(){return this._args[0]}}class Cs extends Ss{constructor(e){super(Zr,[e])}get variableName(){return this._args[0]}}class Ns extends Ss{constructor(e){super(Xr,[e])}toString(){return this.label+":"}get label(){return this._args[0]}}class Os extends Ss{constructor(e){super(es,[e])}get targetLabel(){return this._args[0]}}class ks extends Ss{constructor(e){super(ts,[e])}get targetLabel(){return this._args[0]}}class Is extends Ss{constructor(e,t){super(rs,[e,t])}get constructorName(){return this._args[0]}get targetLabel(){return this._args[1]}}class Rs extends Ss{constructor(e,t){super(ss,[e,t])}get size(){return this._args[0]}get targetLabel(){return this._args[1]}}class Ls extends Ss{constructor(e,t){super(ns,[e,t])}get targetLabel(){return this._args[0]}get nargs(){return this._args[1]}}class As extends Ss{constructor(){super(os,[])}}class Ms extends Ss{constructor(e){super(is,[e])}get size(){return this._args[0]}}class Fs extends Ss{constructor(e){super(as,[e])}get size(){return this._args[0]}}class Bs extends Ss{constructor(e,t,r){super(cs,[e,t,r])}get typeName(){return this._args[0]}get constructorName(){return this._args[1]}get fieldNames(){return this._args[2]}}class Ds extends Ss{constructor(e,t,r){super(us,[e,t,r])}get typeName(){return this._args[0]}get constructorName(){return this._args[1]}get fieldNames(){return this._args[2]}}class Vs extends Ss{constructor(e){super(ls,[e])}get index(){return this._args[0]}}class Hs extends Ss{constructor(e){super(hs,[e])}get fieldName(){return this._args[0]}}class Gs extends Ss{constructor(e){super(ps,[e])}get fieldName(){return this._args[0]}}class Us extends Ss{constructor(){super(ds,[])}}class $s extends Ss{constructor(){super(_s,[])}}class js extends Ss{constructor(e,t){super(gs,[e,t])}get primitiveName(){return this._args[0]}get nargs(){return this._args[1]}}class Ws extends Ss{constructor(){super(fs,[])}}class qs extends Ss{constructor(){super(bs,[])}}class zs extends Ss{constructor(e){super(Ps,[e])}get type(){return this._args[0]}}const Ys=e=>'la palabra clave "'+e+'"';function Js(e,t,r){return 0===e?"ningún "+t:1===e?"un "+t:e.toString()+" "+r}function Ks(e){if(e.isInteger())return["m","número","números"];if(e.isBoolean())return["m","booleano","booleanos"];if(e.isColor())return["m","color","colores"];if(e.isDirection())return["f","dirección","direcciones"];if(e.isList()&&e.contentType.isAny())return["f","lista","listas"];if(e.isList()){const t=Ks(e.contentType);if(void 0===t)return;{const e=t[2];return["f","lista de "+e,"listas de "+e]}}}function Qs(e){const t=Ks(e);if(void 0===t)return e.toString();return t[1]}function Zs(e){const t=Ks(e);if(void 0===t)return"un valor de tipo "+e.toString();{const e=t[0],r=t[1];return"m"===e?"un "+r:"una "+r}}function Xs(e){const t=Ks(e);if(void 0===t)return"de tipo "+e.toString();{const e=t[0],r=t[1];return"m"===e?"un "+r:"una "+r}}function en(e){return"("===e||")"===e?'un paréntesis abierto "("':"["===e||"]"===e?'un corchete abierto "["':"{"===e||"}"===e?'una llave abierta "{"':e}const tn={definition:"una definición (de programa, función, procedimiento, o tipo)",pattern:'un patrón (comodín "_", constructor aplicado a variables, o tupla)',statement:"un comando",expression:"una expresión","procedure call":"una invocación a un procedimiento","field name":"el nombre de un campo",T_EOF:"el final del archivo",T_NUM:"un número",T_STRING:"una cadena (string)",T_UPPERID:"un identificador con mayúsculas",T_LOWERID:"un identificador con minúsculas",T_PROGRAM:Ys("program"),T_INTERACTIVE:Ys("interactive"),T_PROCEDURE:Ys("procedure"),T_FUNCTION:Ys("function"),T_RETURN:Ys("return"),T_IF:Ys("if"),T_THEN:Ys("then"),T_ELSE:Ys("else"),T_REPEAT:Ys("repeat"),T_FOREACH:Ys("foreach"),T_IN:Ys("in"),T_WHILE:Ys("while"),T_SWITCH:Ys("switch"),T_TO:Ys("to"),T_LET:Ys("let"),T_NOT:Ys("not"),T_DIV:Ys("div"),T_MOD:Ys("mod"),T_TYPE:Ys("type"),T_IS:Ys("is"),T_CHOOSE:Ys("choose"),T_WHEN:Ys("when"),T_OTHERWISE:Ys("otherwise"),T_MATCHING:Ys("matching"),T_SELECT:Ys("select"),T_ON:Ys("on"),T_RECORD:Ys("record"),T_VARIANT:Ys("variant"),T_CASE:Ys("case"),T_FIELD:Ys("field"),T_UNDERSCORE:'un guión bajo ("_")',T_LPAREN:'un paréntesis izquierdo ("(")',T_RPAREN:'un paréntesis derecho (")")',T_LBRACE:'una llave izquierda ("{")',T_RBRACE:'una llave derecha ("}")',T_LBRACK:'un corchete izquierdo ("[")',T_RBRACK:'un corchete derecho ("]")',T_COMMA:'una coma (",")',T_SEMICOLON:'un punto y coma (";")',T_RANGE:'un separador de rango ("..")',T_GETS:'una flecha hacia la izquierda ("<-")',T_PIPE:'una barra vertical ("|")',T_ARROW:'una flecha ("->")',T_ASSIGN:'un operador de asignación (":=")',T_EQ:'una comparación por igualdad ("==")',T_NE:'una comparación por desigualdad ("/=")',T_LE:'un menor o igual ("<=")',T_GE:'un mayor o igual (">=")',T_LT:'un menor estricto ("<")',T_GT:'un mayor estricto (">")',T_AND:'el "y" lógico ("&&")',T_OR:'el "o" lógico ("||")',T_CONCAT:'el operador de concatenación de listas ("++")',T_PLUS:'el operador de suma ("+")',T_MINUS:'el operador de resta ("-")',T_TIMES:'el operador de producto ("*")',T_POW:'el operador de potencia ("^")',LocalVariable:"variable",LocalIndex:"índice",LocalParameter:"parámetro",V_Integer:"un número",V_String:"una cadena",V_Tuple:"una tupla",V_List:"una lista",V_Structure:"una estructura","errmsg:unclosed-multiline-comment":"El comentario se abre pero nunca se cierra.","errmsg:unclosed-string-constant":"La comilla que abre no tiene una comilla que cierra correspondiente.","errmsg:numeric-constant-should-not-have-leading-zeroes":"Las constantes numéricas no se pueden escribir con ceros a la izquierda.","errmsg:identifier-must-start-with-alphabetic-character":"Los identificadores deben empezar con un caracter alfabético (a...z,A...Z).","errmsg:unknown-token":e=>'Símbolo desconocido en la entrada: "'+e+'".',"warning:empty-pragma":"Directiva pragma vacía.","warning:unknown-pragma":e=>'Directiva pragma desconocida: "'+e+'".',"errmsg:unmatched-opening-delimiter":e=>"Se encontró "+en(e)+" pero nunca se cierra.","errmsg:unmatched-closing-delimiter":e=>'Se encontró un "'+e+'" pero no había '+en(e)+".","errmsg:unknown-language-option":e=>'Opción desconocida. "'+e+'".',"errmsg:empty-source":"El programa está vacío.","errmsg:expected-but-found":(e,t)=>`Se esperaba ${e}. Se encontró: ${t}.`,"errmsg:pattern-number-cannot-be-negative-zero":'El patrón numérico no puede ser "-0".',"errmsg:return-tuple-cannot-be-empty":"El return tiene que devolver algo.","errmsg:pattern-tuple-cannot-be-singleton":"El patrón para una tupla no puede tener una sola componente. Las tuplas tienen 0, 2, 3, o más componentes, pero no 1.","errmsg:assignment-tuple-cannot-be-singleton":"La asignación a una tupla no puede constar de una sola componente. Las tuplas tienen 0, 2, 3, o más componentes, pero no 1.","errmsg:operators-are-not-associative":(e,t)=>"La expresión usa "+e+" y "+t+", pero estos operadores no se pueden asociar. Quizás faltan paréntesis.","errmsg:obsolete-tuple-assignment":'Se esperaba un comando pero se encontró un paréntesis izquierdo. Nota: la sintaxis de asignación de tuplas "(x1, ..., xN) := y" está obsoleta. Usar "let (x1, ..., xN) := y".',"errmsg:program-already-defined":(e,t)=>"Ya había un programa definido en "+e+".\nNo se puede definir un programa en "+t+".","errmsg:procedure-already-defined":(e,t,r)=>'El procedimiento "'+e+'" está definido dos veces: en '+t+" y en "+r+".","errmsg:function-already-defined":(e,t,r)=>'La función "'+e+'" está definida dos veces: en '+t+" y en "+r+".","errmsg:type-already-defined":(e,t,r)=>`El tipo "${e}" está definido dos veces: en ${t} y en ${r}.`,"errmsg:constructor-already-defined":(e,t,r)=>'El constructor "'+e+'" está definido dos veces: en '+t+" y en "+r+".","errmsg:repeated-field-name":(e,t)=>'El campo "'+t+'" no puede estar repetido para el constructor "'+e+'".',"errmsg:function-and-field-cannot-have-the-same-name":(e,t,r)=>'El nombre "'+e+'" se usa para una función en '+t+" y para un campo en "+r+".","errmsg:source-should-have-a-program-definition":'El código debe tener una definición de "program { ... }".',"errmsg:procedure-should-not-have-return":e=>`El procedimiento "${e}" no debería tener un comando "return".`,"errmsg:function-should-have-return":e=>'La función "'+e+'" debería tener un comando "return".',"errmsg:return-statement-not-allowed-here":'El comando "return" solo puede aparecer como el último comando de una función o como el último comando del programa.',"errmsg:local-name-conflict":(e,t,r,s,n)=>'Conflicto de nombres: "'+e+'" se usa dos veces: como '+t+" en "+r+", y como "+s+" en "+n+".","errmsg:repeated-variable-in-tuple-assignment":e=>`La variable "${e}" está repetida en la asignación de tuplas.`,"errmsg:constructor-used-as-procedure":(e,t)=>'El procedimiento "'+e+'" no está definido. El nombre "'+e+'" es el nombre de un constructor del tipo "'+t+'".',"errmsg:undefined-procedure":e=>'El procedimiento "'+e+'" no está definido.',"errmsg:undefined-function":e=>'La función "'+e+'" no está definida.',"errmsg:procedure-arity-mismatch":(e,t,r)=>'"El procedimiento "'+e+'" espera recibir '+(0,tn["<n>-parameters"])(t)+" pero se lo invoca con "+(0,tn["<n>-arguments"])(r)+".","errmsg:function-arity-mismatch":(e,t,r)=>'La función "'+e+'" espera recibir '+(0,tn["<n>-parameters"])(t)+" pero se la invoca con "+(0,tn["<n>-arguments"])(r)+".","errmsg:structure-pattern-arity-mismatch":(e,t,r)=>'El constructor "'+e+'" tiene '+(0,tn["<n>-fields"])(t)+" pero el patrón tiene "+(0,tn["<n>-parameters"])(r)+".","errmsg:type-used-as-constructor"(e,t){let r;return r=0===t.length?"(no tiene constructores).":1===t.length?"(tiene un constructor: "+t[0]+").":"(sus constructores son: "+t.join(", ")+").",'El constructor "'+e+'" no está definido. El nombre "'+e+'" es el nombre de un tipo '+r},"errmsg:procedure-used-as-constructor":e=>'El constructor "'+e+'" no está definido. El nombre "'+e+'" es el nombre de un procedimiento.',"errmsg:undeclared-constructor":e=>'El constructor "'+e+'" no está definido.',"errmsg:wildcard-pattern-should-be-last":'El comodín "_" debe estar en la última rama.',"errmsg:variable-pattern-should-be-last":e=>'El patrón variable "'+e+'" tiene debe estar en la última rama.',"errmsg:numeric-pattern-repeats-number":e=>'Hay dos ramas distintas para el número "'+e+'".',"errmsg:structure-pattern-repeats-constructor":e=>'Hay dos ramas distintas para el constructor "'+e+'".',"errmsg:structure-pattern-repeats-tuple-arity":e=>"Hay dos ramas distintas para las tuplas de "+e.toString()+" componentes.","errmsg:structure-pattern-repeats-timeout":"Hay dos ramas distintas para el TIMEOUT.","errmsg:pattern-does-not-match-type":(e,t)=>"Los patrones tienen que ser todos del mismo tipo. El patrón debería ser de tipo "+e+"pero es de tipo "+t+".","errmsg:patterns-in-interactive-program-must-be-events":'Los patrones de un "interactive program" deben ser eventos.',"errmsg:patterns-in-interactive-program-cannot-be-variables":"El patrón no puede ser una variable.","errmsg:patterns-in-switch-must-not-be-events":"El patrón no puede ser un evento.","errmsg:structure-construction-repeated-field":(e,t)=>'El campo "'+t+'" está repetido en la instanciación del constructor "'+e+'".',"errmsg:structure-construction-invalid-field":(e,t)=>'El campo "'+t+'" no es un campo válido para el constructor "'+e+'".',"errmsg:structure-construction-missing-field":(e,t)=>'Falta darle valor al campo "'+t+'" del constructor "'+e+'".',"errmsg:structure-construction-cannot-be-an-event":e=>'El constructor "'+e+'" corresponde a un evento, y solamente se puede manejar implícitamente en un programa interactivo (el usuario no puede construir instancias).',"errmsg:forbidden-extension-destructuring-foreach":"El índice de la repetición indexada debe ser un identificador.","errmsg:forbidden-extension-allow-recursion":e=>{const t=[];for(const r of e)t.push("  "+r.caller+" llama a "+r.callee+" ("+r.location.startPos.filename.toString()+":"+r.location.startPos.line.toString()+":"+r.location.startPos.column.toString()+")");return"La recursión está deshabilitada. Hay un ciclo en las invocaciones:\n"+t.join("\n")},"errmsg:patterns-in-foreach-must-not-be-events":"El patrón de un foreach no puede ser un evento.","errmsg:ellipsis":"El programa todavía no está completo.","errmsg:undefined-variable":e=>'La variable "'+e+'" no está definida.',"errmsg:too-few-arguments":e=>'Faltan argumentos para "'+e+'".',"errmsg:expected-structure-but-got":(e,t)=>'Se esperaba una estructura construida con el constructor "'+e+'", pero se recibió '+t+".","errmsg:expected-constructor-but-got":(e,t)=>'Se esperaba una estructura construida con el constructor "'+e+'", pero el constructor recibido es '+t+'".',"errmsg:incompatible-types-on-assignment":(e,t,r)=>'La variable "'+e+'" contenía '+Zs(t)+", no se le puede asignar "+Zs(r)+'".',"errmsg:incompatible-types-on-list-creation":(e,t,r)=>"Todos los elementos de una lista deben ser del mismo tipo. Los elementos son "+function(e){const t=Ks(e);if(void 0===t)return"de tipo "+e.toString();t[0];return t[2]}(t)+", pero el elemento en la posición "+e.toString()+" es "+Xs(r)+".","errmsg:incompatible-types-on-structure-update":(e,t,r)=>'El campo "'+e+'" es '+Xs(t)+". No se lo puede actualizar con "+Zs(r)+".","errmsg:expected-tuple-value-but-got":e=>"Se esperaba una tupla pero se recibió "+Zs(e)+".","errmsg:tuple-component-out-of-bounds":(e,t)=>"Índice fuera de rango. La tupla es de tamaño "+e.toString()+" y el índice es "+t.toString()+".","errmsg:expected-structure-value-but-got":e=>"Se esperaba una estructura pero se recibió "+Zs(e)+".","errmsg:structure-field-not-present":(e,t)=>'La estructura no tiene un campo "'+t+'". Los campos son: ['+e.join(", ")+"].","errmsg:primitive-does-not-exist":e=>`La operación primitiva "${e}" no existe o no está disponible.`,"errmsg:primitive-arity-mismatch":(e,t,r)=>'La operación "'+e+'" espera recibir '+(0,tn["<n>-parameters"])(t)+" pero se la invoca con "+(0,tn["<n>-arguments"])(r)+".","errmsg:primitive-argument-type-mismatch"(e,t,r,s,n){let o="El ";var i;return r>1&&(o+=((i=t)>=1&&i<=9?["","primer","segundo","tercer","cuarto","quinto","sexto","séptimo","octavo","noveno"][i]:"#"+i.toString())+" "),o+="parámetro ",o+='de "'+e+'" ',o+="debería ser "+Xs(s)+" ",o+="pero es "+Xs(n)+".",o},"errmsg:expected-value-of-type-but-got":(e,t)=>"Se esperaba "+Zs(e)+" pero se recibió "+Zs(t)+".","errmsg:expected-value-of-some-type-but-got":(e,t)=>"Se esperaba un valor de alguno de los siguientes tipos: "+function(e){const t=[];for(const r of e)t.push(Qs(r));return t.join(", ")}(e)+". Pero se recibió "+Zs(t)+".","errmsg:expected-values-to-have-compatible-types":(e,t)=>"Los tipos de las expresiones no coinciden: la primera es "+Xs(e)+" y la segunda es "+Xs(t)+".","errmsg:switch-does-not-match":"El valor analizado no coincide con ninguna de las ramas del switch.","errmsg:foreach-pattern-does-not-match":"El elemento no coincide con el patrón esperado por el foreach.","errmsg:cannot-divide-by-zero":"No se puede dividir por cero.","errmsg:negative-exponent":"El exponente de la potencia no puede ser negativo.","errmsg:list-cannot-be-empty":"La lista no puede ser vacía.","errmsg:timeout":e=>"La ejecución del programa demoró más de "+e.toString()+"ms.","errmsg:typecheck-failed":(e,t,r)=>function(e,t,r){let s="";for(let n=0;n<e.length;n++)"%"===e[n]&&n+1<e.length?"%"===e[n+1]?(s+="%",n++):"1"===e[n+1]?(s+=Zs(t),n++):"2"===e[n+1]?(s+=Zs(r),n++):s+="%":s+=e[n];return s}(e,t,r),"errmsg:cannot-move-to":e=>"No se puede mover hacia la dirección "+e+": cae afuera del tablero.","errmsg:cannot-remove-stone":e=>"No se puede sacar una bolita de color "+e+": no hay bolitas de ese color.","TYPE:Integer":"Number","TYPE:String":"String","TYPE:Tuple":"","TYPE:List":"List","TYPE:Event":"Event","CONS:INIT":"INIT","CONS:TIMEOUT":"TIMEOUT","TYPE:Bool":"Bool","CONS:False":"False","CONS:True":"True","TYPE:Color":"Color","CONS:Color0":"Azul","CONS:Color1":"Negro","CONS:Color2":"Rojo","CONS:Color3":"Verde","TYPE:Dir":"Dir","CONS:Dir0":"Norte","CONS:Dir1":"Este","CONS:Dir2":"Sur","CONS:Dir3":"Oeste","PRIM:TypeCheck":"TypeCheck","PRIM:BOOM":"BOOM","PRIM:boom":"boom","PRIM:PutStone":"Poner","PRIM:RemoveStone":"Sacar","PRIM:Move":"Mover","PRIM:GoToEdge":"IrAlBorde","PRIM:EmptyBoardContents":"VaciarTablero","PRIM:numStones":"nroBolitas","PRIM:anyStones":"hayBolitas","PRIM:canMove":"puedeMover","PRIM:next":"siguiente","PRIM:prev":"previo","PRIM:opposite":"opuesto","PRIM:minBool":"minBool","PRIM:maxBool":"maxBool","PRIM:minColor":"minColor","PRIM:maxColor":"maxColor","PRIM:minDir":"minDir","PRIM:maxDir":"maxDir","PRIM:isEmpty":"esVacía","PRIM:head":"primero","PRIM:tail":"sinElPrimero","PRIM:oldTail":"resto","PRIM:init":"comienzo","PRIM:last":"último","<alternative>":e=>"alguna de las siguientes alternativas:\n"+e.map((e=>"  "+e)).join("\n"),"<position>":(e,t,r)=>e+":"+t.toString()+":"+r.toString(),"<n>-parameters":e=>Js(e,"parámetro","parámetros"),"<n>-arguments":e=>Js(e,"argumento","argumentos"),"<n>-fields":e=>Js(e,"campo","campos"),"<pattern-type>":e=>"Event"===e?"evento del programa interactivo":"_TUPLE_"===e.substring(0,7)?"tupla de "+e.substring(7)+" componentes":e},rn={};for(const e in tn)rn[e]=tn[e];rn["TYPE:Color"]="Color",rn["CONS:Color0"]="Blue",rn["CONS:Color1"]="Black",rn["CONS:Color2"]="Red",rn["CONS:Color3"]="Green",rn["TYPE:Dir"]="Dir",rn["CONS:Dir0"]="North",rn["CONS:Dir1"]="East",rn["CONS:Dir2"]="South",rn["CONS:Dir3"]="West",rn["PRIM:PutStone"]="Drop",rn["PRIM:RemoveStone"]="Grab",rn["PRIM:Move"]="Move",rn["PRIM:GoToEdge"]="GoToEdge",rn["PRIM:EmptyBoardContents"]="EmptyBoardContents",rn["PRIM:numStones"]="numStones",rn["PRIM:anyStones"]="anyStones",rn["PRIM:canMove"]="canMove",rn["PRIM:next"]="next",rn["PRIM:prev"]="prev",rn["PRIM:opposite"]="opposite",rn["PRIM:minBool"]="minBool",rn["PRIM:maxBool"]="maxBool",rn["PRIM:minColor"]="minColor",rn["PRIM:maxColor"]="maxColor",rn["PRIM:minDir"]="minDir",rn["PRIM:maxDir"]="maxDir",rn["PRIM:head"]="head",rn["PRIM:tail"]="tail",rn["PRIM:oldTail"]="tail",rn["PRIM:init"]="init",rn["PRIM:last"]="last";const sn=e=>`‘a palavra chave "${e}"`;function nn(e,t,r){return 0===e?"nenhum "+t:1===e?"um "+t:e.toString()+" "+r}const on={};for(const e in tn)on[e]=tn[e];on.definition="uma definição (de programa, função, procedimento, ou tipo)",on.pattern='um padrão (comodín "_", construtor aplicado a variáveis, ou tupla)',on.statement="um comando",on.expression="uma expressão",on["procedure call"]="uma invocação a um procedimento",on["field name"]="o nome de um campo",on.T_EOF="o fim do arquivo",on.T_NUM="um número",on.T_STRING="uma corrente (string)",on.T_UPPERID="um identificador com maiúsculas",on.T_LOWERID="um identificador com minúsculas",on.T_PROGRAM=sn("program"),on.T_INTERACTIVE=sn("interactive"),on.T_PROCEDURE=sn("procedure"),on.T_FUNCTION=sn("function"),on.T_RETURN=sn("return"),on.T_IF=sn("if"),on.T_THEN=sn("then"),on.T_ELSE=sn("else"),on.T_REPEAT=sn("repeat"),on.T_FOREACH=sn("foreach"),on.T_IN=sn("in"),on.T_WHILE=sn("while"),on.T_SWITCH=sn("switch"),on.T_TO=sn("to"),on.T_LET=sn("let"),on.T_NOT=sn("not"),on.T_DIV=sn("div"),on.T_MOD=sn("mod"),on.T_TYPE=sn("type"),on.T_IS=sn("is"),on.T_RECORD=sn("record"),on.T_VARIANT=sn("variant"),on.T_CASE=sn("case"),on.T_FIELD=sn("field"),on.T_UNDERSCORE='um sublinhado ("_")',on.T_LPAREN='um parênteses esquerdo ("(")',on.T_RPAREN='um parênteses direito (")")',on.T_LBRACE='uma chave esquerda ("{")',on.T_RBRACE='uma chave direita ("}")',on.T_LBRACK='um colchete esquerdo ("[")',on.T_RBRACK='um colchete direito ("]")',on.T_COMMA='uma vírgula  (",")',on.T_SEMICOLON='um ponto e vírgula (";")',on.T_RANGE='um separador de intervalo ("..")',on.T_GETS='uma flecha para a esquerda ("<-")',on.T_PIPE='uma barra vertical ("|")',on.T_ARROW='uma flecha ("->")',on.T_ASSIGN='um operador de designação  (":=")',on.T_EQ='uma comparação por igualdade ("==")',on.T_NE='uma comparação por desigualdade ("/=")',on.T_LE='um menor ou igual ("<=")',on.T_GE='um maior ou igual (">=")',on.T_LT='um menor estrito ("<")',on.T_GT='um maior estrito (">")',on.T_AND='o "e" lógico ("&&")',on.T_OR='o "ou" lógico ("||")',on.T_CONCAT='o operador de concatenação de listas ("++")',on.T_PLUS='o operador de soma ("+")',on.T_MINUS='o operador de diferença ("-")',on.T_TIMES='o operador de produto ("*")',on.T_POW='o operador de potência ("^")',on.LocalVariable="variável",on.LocalIndex="índice",on.LocalParameter="parâmetro",on.V_Integer="um número",on.V_String="uma cadeia",on.V_Tuple="uma tupla",on.V_List="uma lista",on.V_Structure="uma estrutura",on["errmsg:unclosed-multiline-comment"]="O comentário abre mas nunca fecha.",on["errmsg:unclosed-string-constant"]="As aspas que abrem não possuem as aspas correspondentes que fecham.",on["errmsg:numeric-constant-should-not-have-leading-zeroes"]="As constantes numéricas não podem ser escritas com zeros à esquerda.",on["errmsg:identifier-must-start-with-alphabetic-character"]="Os identificadores devem começar com um caractere alfabético (a...z,A...Z).",on["errmsg:unknown-token"]=e=>`Símbolo desconhecido na entrada: "${e}".`,on["warning:empty-pragma"]="Diretiva pragma vazia.",on["warning:unknown-pragma"]=e=>'Diretiva pragma desconhecida: "'+e+'".',on["errmsg:empty-source"]="O programa está vazio.",on["errmsg:expected-but-found"]=(e,t)=>`Esperava-se ${e}.\nEncontrado: ${t}.`,on["errmsg:pattern-number-cannot-be-negative-zero"]='O padrão numérico não pode ser "-0".',on["errmsg:pattern-tuple-cannot-be-singleton"]="O padrão para uma tupla não pode ter apenas um componente. As tuplas têm 0, 2, 3, ou mais componentes, mas não 1.",on["errmsg:assignment-tuple-cannot-be-singleton"]="A designação a uma tupla não pode ser  constituída por apenas um componente. As tuplas têm 0, 2, 3, ou mais componentes, mas não 1.",on["errmsg:operators-are-not-associative"]=(e,t)=>"A expressão usa "+e+" e "+t+", mas estes operadores não podem ser associados. Talvez faltam parênteses.",on["errmsg:obsolete-tuple-assignment"]='Esperava-se um comando mas não foi encontrado um parênteses esquerdo. Nota: a sintaxe de designação de tuplas "(x1, ..., xN) := y" está obsoleta. Usar "let (x1, ..., xN) := y".',on["errmsg:program-already-defined"]=(e,t)=>"Já havia um programa definido em "+e+".\nNão é possível definir um programa em "+t+".",on["errmsg:procedure-already-defined"]=(e,t,r)=>'O procedimiento "'+e+'" está definido duas vezes: em '+t+" e em "+r+".",on["errmsg:function-already-defined"]=(e,t,r)=>`A função "${e}" está definida duas vezes: em ${t} e em ${r}.`,on["errmsg:type-already-defined"]=(e,t,r)=>`O tipo "${e}" está definido duas vezes: em ${t} e em ${r}.`,on["errmsg:constructor-already-defined"]=(e,t,r)=>`O construtor "${e}" está definido duas vezes: em ${t} e em ${r}.`,on["errmsg:repeated-field-name"]=(e,t)=>'O campo "'+t+'" não pode estar repetido para o construtor "'+e+'".',on["errmsg:function-and-field-cannot-have-the-same-name"]=(e,t,r)=>'O nome "'+e+'" usa-se para uma função em '+t+" e para um campo em "+r+".",on["errmsg:source-should-have-a-program-definition"]='O código deve ter uma definição de "program { ... }".',on["errmsg:procedure-should-not-have-return"]=e=>`O procedimento "${e}" não deveria ter um comando "return".`,on["errmsg:function-should-have-return"]=e=>'A função "'+e+'" deveria ter um comando "return".',on["errmsg:return-statement-not-allowed-here"]='O comando "return"  pode aparecer apenas como o último comando de uma função ou como o último comando do programa.',on["errmsg:local-name-conflict"]=(e,t,r,s,n)=>'Conflito de nomes: "'+e+'" se usa duas vezes: como '+t+" em "+r+", e como "+s+" em "+n+".",on["errmsg:repeated-variable-in-tuple-assignment"]=e=>`La variável "${e}" está repetida na designação de tuplas.`,on["errmsg:constructor-used-as-procedure"]=(e,t)=>'O procedimento "'+e+'" não está definido. O nome "'+e+'" é o nome de um construtor do tipo "'+t+'".',on["errmsg:undefined-procedure"]=e=>'O procedimento "'+e+'" não está definido.',on["errmsg:undefined-function"]=e=>'A função "'+e+'" não está definida.',on["errmsg:procedure-arity-mismatch"]=(e,t,r)=>'O procedimento "'+e+'" espera receber '+(0,tn["<n>-parameters"])(t)+" mas é invocado com "+(0,tn["<n>-arguments"])(r)+".",on["errmsg:function-arity-mismatch"]=(e,t,r)=>'A função "'+e+'" espera receber '+(0,tn["<n>-parameters"])(t)+" mas é invocado com "+(0,tn["<n>-arguments"])(r)+".",on["errmsg:structure-pattern-arity-mismatch"]=(e,t,r)=>'O construtor "'+e+'" tem '+(0,tn["<n>-fields"])(t)+" mas o padrão tem "+(0,tn["<n>-parameters"])(r)+".",on["errmsg:type-used-as-constructor"]=(e,t)=>{let r;return r=0===t.length?"(não tem construtores).":1===t.length?"(tem um construtor: "+t[0]+").":"(seus construtores são: "+t.join(", ")+").",'O construtor "'+e+'" não está definido. O nome "'+e+'" é o nome de um tipo '+r},on["errmsg:procedure-used-as-constructor"]=e=>'O construtor "'+e+'" não está definido. O nome "'+e+'" é o nome de um procedimento.',on["errmsg:undeclared-constructor"]=e=>'O construtor "'+e+'" não está definido.',on["errmsg:wildcard-pattern-should-be-last"]='O comodín "_" tem que ser o último ramo do switch.',on["errmsg:numeric-pattern-repeats-number"]=e=>'Tem dois ramos diferentes para o número "'+e+'".',on["errmsg:structure-pattern-repeats-constructor"]=e=>'Há dois ramos distintos para o construtor "'+e+'".',on["errmsg:structure-pattern-repeats-tuple-arity"]=e=>"Há dois ramos distintos para as tuplas de "+e.toString()+" componentes.",on["errmsg:structure-pattern-repeats-timeout"]="Há dois ramos distintos para o TIMEOUT.",on["errmsg:pattern-does-not-match-type"]=(e,t)=>'Os padrões devem ser todos do mesmo tipo. O padrão deveria ser de tipo "'+e+'" pero es de tipo "'+t+'".',on["errmsg:patterns-in-interactive-program-must-be-events"]='Os padrões de um "interactive program" devem ser eventos.',on["errmsg:patterns-in-switch-must-not-be-events"]='Os padrões de um "switch" não podem ser eventos.',on["errmsg:structure-construction-repeated-field"]=(e,t)=>'O campo "'+t+'" está repetido em a instanciação do construtor "'+e+'".',on["errmsg:structure-construction-invalid-field"]=(e,t)=>'O campo "'+t+'" não é um campo válido para o construtor "'+e+'".',on["errmsg:structure-construction-missing-field"]=(e,t)=>`Falta dar valor ao campo "${t}" do construtor "${e}".`,on["errmsg:structure-construction-cannot-be-an-event"]=e=>'O construtor "'+e+'" corresponde a um evento, e só pode ser administrado implicitamente em um programa interativo (o usuário não pode construir instâncias).',on["errmsg:undefined-variable"]=e=>'A variável "'+e+'" não está definida.',on["errmsg:too-few-arguments"]=e=>'Faltam argumentos para "'+e+'".',on["errmsg:expected-structure-but-got"]=(e,t)=>'Esperava-se uma estrutura construída com o construtor "'+e+'", mas foi recebido '+t+".",on["errmsg:expected-constructor-but-got"]=(e,t)=>'Esperava-se uma estrutura construída com o construtor "'+e+'", mas o construtor recebido é '+t+'".',on["errmsg:incompatible-types-on-assignment"]=(e,t,r)=>'A variável "'+e+'" continha un valor do tipo '+t+", não é possível designar um valor de tipo "+r+'".',on["errmsg:incompatible-types-on-list-creation"]=(e,t,r)=>"Todos os elementos de uma lista devem ser do mesmo tipo. Os elementos são do tipo "+t+", mas o elemento na posição "+e.toString()+" é do tipo "+r+".",on["errmsg:incompatible-types-on-structure-update"]=(e,t,r)=>'O campo "'+e+'" é do tipo '+t+". Não pode ser atualizado com um valor do tipo "+r+".",on["errmsg:expected-tuple-value-but-got"]=e=>`Esperava-se uma tupla mas um valor não foi recebido de tipo ${e}.`,on["errmsg:tuple-component-out-of-bounds"]=(e,t)=>"Índice fora do intervalo. A tupla é do tamanho "+e.toString()+" e o índice é "+t.toString()+".",on["errmsg:expected-structure-value-but-got"]=e=>`Se esperaba una estructura pero se recibió un valor de tipo ${e}.`,on["errmsg:structure-field-not-present"]=(e,t)=>'A estrutura não possui um campo "'+t+'". Os campos são: ['+e.join(", ")+"].",on["errmsg:primitive-does-not-exist"]=e=>`A operação primitiva "${e}" não existe ou não está disponível.`,on["errmsg:primitive-arity-mismatch"]=(e,t,r)=>'A operação "'+e+'" espera receber '+(0,tn["<n>-parameters"])(t)+" mas é invocada com "+(0,tn["<n>-arguments"])(r)+".",on["errmsg:primitive-argument-type-mismatch"]=(e,t,r,s)=>"O parâmetro #"+t.toString()+' da operação "'+e+'" deveria ser do tipo '+r+" mas o argumento é do tipo "+s+".",on["errmsg:expected-value-of-type-but-got"]=(e,t)=>"Esperava-se um valor do tipo "+e+" mas foi recebido um valor do tipo "+t+".",on["errmsg:expected-value-of-some-type-but-got"]=(e,t)=>"Esperava-se um valor de algum dos seguintes tipos: "+e.join(", ")+"; mas foi recebido um valor do tipo "+t+".",on["errmsg:expected-values-to-have-compatible-types"]=(e,t)=>"Os tipos dos valores devem ser compatíveis, mas um é do tipo "+e+" e o outro é do tipo "+t+".",on["errmsg:switch-does-not-match"]="O valor analisado não coincide com nenhum dos ramos do switch.",on["errmsg:cannot-divide-by-zero"]="Não é possível dividir por zero.",on["errmsg:list-cannot-be-empty"]="A lista não pode ser vazia.",on["errmsg:timeout"]=e=>"A execução do programa demorou mais de "+e.toString()+"ms.",on["errmsg:cannot-move-to"]=e=>"Não é possível mover para a direção "+e+": cai fora do tabuleiro.",on["errmsg:cannot-remove-stone"]=e=>"Não é posível retirar uma pedra de cor "+e+": não há pedras dessa cor.",on["TYPE:Color"]="Cor",on["CONS:Color0"]="Azul",on["CONS:Color1"]="Preto",on["CONS:Color2"]="Vermelho",on["CONS:Color3"]="Verde",on["TYPE:Dir"]="Dir",on["CONS:Dir0"]="Norte",on["CONS:Dir1"]="Leste",on["CONS:Dir2"]="Sul",on["CONS:Dir3"]="Oeste",on["PRIM:PutStone"]="Colocar",on["PRIM:RemoveStone"]="Retirar",on["PRIM:Move"]="Mover",on["PRIM:GoToEdge"]="IrABorda",on["PRIM:EmptyBoardContents"]="EsvaziarTabuleiro",on["PRIM:numStones"]="nroPedras",on["PRIM:anyStones"]="haPedras",on["PRIM:canMove"]="podeMover",on["PRIM:next"]="seguinte",on["PRIM:prev"]="previo",on["PRIM:opposite"]="oposto",on["PRIM:minBool"]="minBool",on["PRIM:maxBool"]="maxBool",on["PRIM:minColor"]="minCor",on["PRIM:maxColor"]="maxCor",on["PRIM:minDir"]="minDir",on["PRIM:maxDir"]="maxDir",on["PRIM:head"]="primeiro",on["PRIM:tail"]="resto",on["PRIM:oldTail"]="resto",on["PRIM:init"]="comeco",on["PRIM:last"]="ultimo",on["<alternative>"]=e=>"alguma das seguintes alternativas:\n"+e.map((e=>"  "+e)).join("\n"),on["<position>"]=(e,t,r)=>e+":"+t.toString()+":"+r.toString(),on["<n>-parameters"]=e=>nn(e,"parâmetro","parâmetros"),on["<n>-arguments"]=e=>nn(e,"argumento","argumentos"),on["<n>-fields"]=e=>nn(e,"campo","campos"),on["<pattern-type>"]=e=>"Event"===e?"evento do programa interativo":"_TUPLE_"===e.substring(0,7)?"tupla de "+e.substring(7)+" componentes":e;const an={es:tn,en:rn,pt:on},cn=e=>an.es[e],un=Symbol.for("Ty_Any"),ln=Symbol.for("Ty_Integer"),hn=Symbol.for("Ty_String"),pn=Symbol.for("Ty_Tuple"),mn=Symbol.for("Ty_List"),dn=Symbol.for("Ty_Structure"),_n=Symbol.for("?");class gn{constructor(e){this._tag=e}get tag(){return this._tag}isAny(){return!1}isInteger(){return!1}isString(){return!1}isTuple(){return!1}isList(){return!1}isStructure(){return!1}isBoolean(){return!1}isColor(){return!1}isDirection(){return!1}}class fn extends gn{constructor(){super(un)}toString(){return"?"}isAny(){return!0}}class bn extends gn{constructor(){super(ln)}toString(){return cn("TYPE:Integer")}isInteger(){return!0}}class Pn extends gn{constructor(){super(hn)}toString(){return cn("TYPE:String")}isString(){return!0}}class vn extends gn{constructor(e){super(pn),this._componentTypes=e}get componentTypes(){return this._componentTypes}toString(){const e=[];for(const t of this._componentTypes)e.push(t.toString());return cn("TYPE:Tuple")+"("+e.join(", ")+")"}isTuple(){return!0}}class Tn extends gn{constructor(e){super(mn),this._contentType=e}get contentType(){return this._contentType}toString(){let e="";return this._contentType.isAny()||(e="("+this._contentType.toString()+")"),cn("TYPE:List")+e}isList(){return!0}}class Sn extends gn{constructor(e,t){super(dn),this._typeName=e,this._cases=t}get typeName(){return this._typeName}get cases(){return this._cases}toString(){const e=[];for(const t of Nn(this._cases)){const r=this._cases[t],s=[];for(const e of Nn(r))s.push(e+" <- "+r[e].toString());0!==s.length&&e.push(t+"("+s.join(", ")+")")}return 0===e.length?this._typeName:this._typeName+" { "+e.join(" | ")+" }"}isStructure(){return!0}isBoolean(){return this._typeName===cn("TYPE:Bool")}isColor(){return this._typeName===cn("TYPE:Color")}isDirection(){return this._typeName===cn("TYPE:Dir")}}function yn(e,t){return void 0===e||void 0===t?void 0:e.tag===un?t:t.tag===un||e.tag===ln&&t.tag===ln||e.tag===hn&&t.tag===hn?e:e.tag===pn&&t.tag===pn?En(e,t):e.tag===mn&&t.tag===mn?wn(e,t):e.tag===dn&&t.tag===dn?xn(e,t):void 0}const En=(e,t)=>{if(e.componentTypes.length!==t.componentTypes.length)return;const r=[];for(let s=0;s<e.componentTypes.length;s++){const n=yn(e.componentTypes[s],t.componentTypes[s]);if(void 0===n)return;r.push(n)}return new vn(r)},wn=(e,t)=>{const r=yn(e.contentType,t.contentType);if(void 0!==r)return new Tn(r)},xn=(e,t)=>{if(e.typeName!==t.typeName)return;const r={};function s(e,t){for(const s in e.cases)s in t.cases||(r[s]=e.cases[s])}s(e,t),s(t,e);for(const s in e.cases)if(s in t.cases){const n=Cn(e.cases[s],t.cases[s]);if(void 0===n)return;r[s]=n}return new Sn(e.typeName,r)},Cn=(e,t)=>{function r(e,t){for(const r in e)if(!(r in t))throw Error("Join fields: structures built using the same constructor should have the same set of fields.")}r(e,t),r(t,e);const s={};for(const r in e){const n=yn(e[r],t[r]);if(void 0===n)return;s[r]=n}return s};function Nn(e){const t=[];for(const r in e)t.push(r);return t.sort()}const On=Symbol.for("V_Integer"),kn=Symbol.for("V_String"),In=Symbol.for("V_Tuple"),Rn=Symbol.for("V_List"),Ln=Symbol.for("V_Structure");class An{constructor(e){this._tag=e}get tag(){return this._tag}type(){return new gn(_n)}isInteger(){return this.type().isInteger()}isString(){return this.type().isString()}isTuple(){return this.type().isTuple()}isList(){return this.type().isList()}isStructure(){return this.type().isStructure()}isBoolean(){return this.type().isBoolean()}equal(e){return!1}}class Mn extends An{constructor(e){super(On),this._number="number"==typeof e?e:parseInt(e,10)}toString(){return this._number.toString()}get number(){return this._number}type(){return new bn}equal(e){return e.tag===On&&this.number===e.number}add(e){const t=this._number,r=e._number;return new Mn(t+r)}sub(e){const t=this._number,r=e._number;return new Mn(t-r)}mul(e){const t=this._number,r=e._number;return new Mn(t*r==0?0:t*r)}div(e){const t=new Mn(0);if(this.gt(t)===e.gt(t)){const t=this.abs()._number,r=e.abs()._number,s=0===Math.floor(t/r)?0:Math.floor(t/r);return new Mn(s)}{const t=e.abs().sub(new Mn(1)),r=this.abs().add(t)._number,s=e.abs()._number,n=-1*Math.floor(r/s)==0?0:-1*Math.floor(r/s);return new Mn(n)}}mod(e){const t=this.div(e);return this.sub(t.mul(e))}pow(e){const t=this._number,r=e._number;return new Mn(Math.pow(t,r))}eq(e){return this.equal(e)}ne(e){return!this.equal(e)}le(e){return this._number<=e._number}lt(e){return this._number<e._number}ge(e){return this._number>=e._number}gt(e){return this._number>e._number}negate(){let e=-1*this._number;return e=0===e?0:e,new Mn(e)}abs(){return this.gt(new Mn(0))?this:this.negate()}asNumber(){return this._number}}class Fn extends An{constructor(e){super(kn),this._string=e}toString(){const e=['"'];for(let t=0;t<this._string.length;t++){const r=this._string[t];switch(r){case'"':e.push("\\"),e.push('"');break;case"\\":e.push("\\"),e.push("\\");break;case"":e.push("\\"),e.push("a");break;case"\b":e.push("\\"),e.push("b");break;case"\f":e.push("\\"),e.push("f");break;case"\n":e.push("\\"),e.push("n");break;case"\r":e.push("\\"),e.push("r");break;case"\t":e.push("\\"),e.push("t");break;case"\v":e.push("\\"),e.push("v");break;default:e.push(r)}}return e.push('"'),e.join("")}get string(){return this._string}equal(e){return e.tag===kn&&this.string===e.string}type(){return new Pn}}class Bn extends An{constructor(e){super(In),this._components=e,this._type=this._inferType()}toString(){const e=[];for(const t of this._components)e.push(t.toString());return"("+e.join(", ")+")"}get components(){return this._components}size(){return this._components.length}equal(e){if(e.tag!==In)return!1;if(this.components.length!==e.components.length)return!1;for(let t=0;t<this.components.length;t++)if(!this.components[t].equal(e.components[t]))return!1;return!0}type(){return this._type}_inferType(){const e=[];for(const t of this._components)e.push(t.type());return new vn(e)}}class Dn extends An{constructor(e){super(Rn),this._elements=e,this._type=this._inferType()}toString(){const e=[];for(const t of this._elements)e.push(t.toString());return"["+e.join(", ")+"]"}get elements(){return this._elements}equal(e){if(e.tag!==Rn)return!1;if(this.elements.length!==e.elements.length)return!1;for(let t=0;t<this.elements.length;t++)if(!this.elements[t].equal(e.elements[t]))return!1;return!0}type(){return this._type}length(){return this._elements.length}_inferType(){let e=new fn;for(const t of this._elements)e=yn(e,t.type());return new Tn(e)}append(e){const t=[];for(const e of this.elements)t.push(e);for(const r of e.elements)t.push(r);return new Dn(t)}head(){return this.elements[0]}tail(){const e=[];for(let t=1;t<this.elements.length;t++)e.push(this.elements[t]);return new Dn(e)}init(){const e=[];for(let t=0;t<this.elements.length-1;t++)e.push(this.elements[t]);return new Dn(e)}last(){return this.elements[this.elements.length-1]}}class Vn extends An{constructor(e,t,r){super(Ln),this._typeName=e,this._constructorName=t,this._fields=r}toString(){const e=[],t=this.fieldNames();if(0===t.length)return this._constructorName;for(const r of t)e.push(r+" <- "+this.fields[r].toString());return this._constructorName+"("+e.join(", ")+")"}get typeName(){return this._typeName}get constructorName(){return this._constructorName}get fields(){return this._fields}fieldNames(){return Nn(this._fields)}_clone(){const e={};for(const t in this._fields)e[t]=this._fields[t];return new Vn(this._typeName,this._constructorName,e)}updateFields(e){const t=this._clone();for(const r in e)t.fields[r]=e[r];return t}equal(e){if(e.tag!==Ln)return!1;if(this.constructorName!==e.constructorName)return!1;const t=this.fieldNames();for(const r of t)if(!this.fields[r].equal(e.fields[r]))return!1;return!0}type(){const e={};for(const t in this._fields)e[t]=this._fields[t].type();const t={};return t[this._constructorName]=e,new Sn(this._typeName,t)}}function Hn(e,t,r,s){throw new Pr(e,t,r,s)}const Gn=()=>[cn("CONS:Color0"),cn("CONS:Color1"),cn("CONS:Color2"),cn("CONS:Color3")],Un=()=>[cn("CONS:Dir0"),cn("CONS:Dir1"),cn("CONS:Dir2"),cn("CONS:Dir3")];const $n=function(){const e=["","CTRL_","ALT_","SHIFT_","CTRL_ALT_","CTRL_SHIFT_","ALT_SHIFT_","CTRL_ALT_SHIFT_"],t=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9"].concat(["SPACE","RETURN","TAB","BACKSPACE","ESCAPE","INSERT","DELETE","HOME","END","PAGEUP","PAGEDOWN","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12"]).concat(["AMPERSAND","ASTERISK","AT","BACKSLASH","CARET","COLON","DOLLAR","EQUALS","EXCLAIM","GREATER","HASH","LESS","PERCENT","PLUS","SEMICOLON","SLASH","QUESTION","QUOTE","QUOTEDBL","UNDERSCORE","LEFTPAREN","RIGHTPAREN","LEFTBRACKET","RIGHTBRACKET","LEFTBRACE","RIGHTBRACE"]).concat(["LEFT","RIGHT","UP","DOWN"]),r=[];for(const s of e)for(const e of t)r.push("K_"+s+e);return r}(),jn=(e,t)=>e.indexOf(t),Wn=(e,t)=>e[t];class qn{constructor(){this._width=11,this._height=7,this._board=[];for(let e=0;e<this._width;e++){const e=[];for(let t=0;t<this._height;t++)e.push(this._emptyCell());this._board.push(e)}this._head={x:0,y:0}}clone(){const e=new qn;e._width=this._width,e._height=this._height,e._board=[];for(let t=0;t<this._width;t++){const r=[];for(let e=0;e<this._height;e++){const s={};for(const r of Gn())s[r]=this._board[t][e][r];r.push(s)}e._board.push(r)}return e._head={x:this._head.x,y:this._head.y},e}dump(){const e={head:[],width:0,height:0,board:[]};e.width=this._width,e.height=this._height,e.head=[this._head.x,this._head.y],e.board=[];for(let t=0;t<this._width;t++){const r=[];for(let e=0;e<this._height;e++){const s={};s.a=this._board[t][e][cn("CONS:Color0")].asNumber(),s.n=this._board[t][e][cn("CONS:Color1")].asNumber(),s.r=this._board[t][e][cn("CONS:Color2")].asNumber(),s.v=this._board[t][e][cn("CONS:Color3")].asNumber(),r.push(s)}e.board.push(r)}return e}load(e){this._width=e.width,this._height=e.height,this._head.x=e.head[0],this._head.y=e.head[1],this._board=[];for(let t=0;t<this._width;t++){const r=[];for(let s=0;s<this._height;s++){const n=e.board[t][s],o={};o[cn("CONS:Color0")]=new Mn(n.a),o[cn("CONS:Color1")]=new Mn(n.n),o[cn("CONS:Color2")]=new Mn(n.r),o[cn("CONS:Color3")]=new Mn(n.v),r.push(o)}this._board.push(r)}}putStone(e){let t=this._board[this._head.x][this._head.y][e];t=t.add(new Mn(1)),this._board[this._head.x][this._head.y][e]=t}removeStone(e){let t=this._board[this._head.x][this._head.y][e];if(t.le(new Mn(0)))throw Error("Cannot remove stone.");t=t.sub(new Mn(1)),this._board[this._head.x][this._head.y][e]=t}numStones(e){return this._board[this._head.x][this._head.y][e]}move(e){if(!this.canMove(e))throw Error("Cannot move.");const t=this._deltaForDirection(e);this._head.x+=t[0],this._head.y+=t[1]}goToEdge(e){if(e===cn("CONS:Dir0"))this._head.y=this._height-1;else if(e===cn("CONS:Dir1"))this._head.x=this._width-1;else if(e===cn("CONS:Dir2"))this._head.y=0;else{if(e!==cn("CONS:Dir3"))throw Error("Invalid direction: "+e);this._head.x=0}}emptyBoardContents(){for(let e=0;e<this._width;e++)for(let t=0;t<this._height;t++)this._board[e][t]=this._emptyCell()}canMove(e){const t=this._deltaForDirection(e),r=this._head.x+t[0],s=this._head.y+t[1];return r>=0&&r<this._width&&s>=0&&s<this._height}_deltaForDirection(e){let t;if(e===cn("CONS:Dir0"))t=[0,1];else if(e===cn("CONS:Dir1"))t=[1,0];else if(e===cn("CONS:Dir2"))t=[0,-1];else{if(e!==cn("CONS:Dir3"))throw Error("Invalid direction: "+e);t=[-1,0]}return t}_emptyCell(){const e={};for(const t of Gn())e[t]=new Mn(0);return e}}class zn{constructor(e,t,r){this._argumentTypes=e,this._argumentValidator=t,this._implementation=r}get argumentTypes(){return this._argumentTypes}nargs(){return this._argumentTypes.length}call(e,t){return this._implementation.apply(void 0,[e].concat(t))}validateArguments(e,t,r,s){this._argumentValidator(e,t,r,s)}}const Yn=new fn,Jn=new bn,Kn=new Pn,Qn=()=>new Sn(cn("TYPE:Bool"),{}),Zn=new Tn(new fn);function Xn(e){return new Vn(cn("TYPE:Bool"),cn(e?"CONS:True":"CONS:False"),{})}const eo=e=>e.constructorName===cn("CONS:True"),to=()=>new Sn(cn("TYPE:Color"),{}),ro=e=>new Vn(cn("TYPE:Color"),e,{}),so=e=>e.constructorName,no=()=>new Sn(cn("TYPE:Dir"),{}),oo=e=>new Vn(cn("TYPE:Dir"),e,{}),io=e=>e.constructorName;function ao(){}const co=e=>void 0!==yn(e.type(),Jn),uo=e=>void 0!==yn(e.type(),Qn()),lo=e=>void 0!==yn(e.type(),to()),ho=e=>void 0!==yn(e.type(),no()),po=()=>[Jn,Qn(),no()],mo=()=>[Jn,Qn(),to(),no()];function _o(e){if(uo(e))return eo(e)?1:0;if(lo(e))return jn(Gn(),so(e));if(ho(e))return jn(Un(),io(e));throw Error("Value should be Bool, Color or Dir.")}function go(e,t){if(co(e))return Xn(e.lt(t));return Xn(_o(e)<_o(t))}function fo(e,t){if(co(e))return Xn(e.gt(t));return Xn(_o(e)>_o(t))}function bo(e){if(co(e))return e.add(new Mn(1));if(uo(e))return eo(e)?Xn(!1):Xn(!0);if(lo(e))return ro((r=so(e),Wn(Gn(),(jn(Gn(),r)+1)%4)));if(ho(e))return oo((t=io(e),Wn(Un(),(jn(Un(),t)+1)%4)));throw Error("genericNext: value has no next.");var t,r}function Po(e){if(co(e))return e.sub(new Mn(1));if(uo(e))return eo(e)?Xn(!1):Xn(!0);if(lo(e))return ro((r=so(e),Wn(Gn(),(jn(Gn(),r)+3)%4)));if(ho(e))return oo((t=io(e),Wn(Un(),(jn(Un(),t)+3)%4)));throw Error("genericPrev: value has no prev.");var t,r}function vo(e){if(co(e))return e.negate();if(uo(e))return Xn(!eo(e));if(ho(e))return oo((t=io(e),Wn(Un(),(jn(Un(),t)+2)%4)));throw Error("genericOpposite: value has no opposite.");var t}function To(e,t,r,s){for(const e of s)if(void 0!==yn(r.type(),e))return;Hn(e,t,"expected-value-of-some-type-but-got",[s,r.type()])}function So(e,t,r,s){void 0===yn(r.type(),s.type())&&Hn(e,t,"expected-values-to-have-compatible-types",[r.type(),s.type()])}class yo{constructor(){this._primitiveTypes={},this._primitiveProcedures={},this._primitiveFunctions={},this._primitiveTypes[cn("TYPE:Bool")]={};for(const e of[cn("CONS:False"),cn("CONS:True")])this._primitiveTypes[cn("TYPE:Bool")][e]=[];this._primitiveTypes[cn("TYPE:Color")]={};for(const e of Gn())this._primitiveTypes[cn("TYPE:Color")][e]=[];this._primitiveTypes[cn("TYPE:Dir")]={};for(const e of Un())this._primitiveTypes[cn("TYPE:Dir")][e]=[];this._primitiveTypes[cn("TYPE:Event")]={};for(const e of[cn("CONS:INIT"),cn("CONS:TIMEOUT")].concat($n))this._primitiveTypes[cn("TYPE:Event")][e]=[];this._primitiveProcedures[cn("PRIM:TypeCheck")]=new zn([Yn,Yn,Kn],((e,t,r,s)=>{const n=s[0],o=s[1],i=s[2];void 0===yn(n.type(),o.type())&&Hn(e,t,"typecheck-failed",[i.string,n.type(),o.type()])}),((e,t)=>{})),this._primitiveProcedures[cn("PRIM:PutStone")]=new zn([to()],ao,((e,t)=>{e.putStone(so(t))})),this._primitiveProcedures[cn("PRIM:RemoveStone")]=new zn([to()],((e,t,r,s)=>{const n=so(s[0]);r.numStones(n).le(new Mn(0))&&Hn(e,t,"cannot-remove-stone",[n])}),((e,t)=>{e.removeStone(so(t))})),this._primitiveProcedures[cn("PRIM:Move")]=new zn([no()],((e,t,r,s)=>{const n=io(s[0]);r.canMove(n)||Hn(e,t,"cannot-move-to",[n])}),((e,t)=>{e.move(io(t))})),this._primitiveProcedures[cn("PRIM:GoToEdge")]=new zn([no()],ao,((e,t)=>{e.goToEdge(io(t))})),this._primitiveProcedures[cn("PRIM:EmptyBoardContents")]=new zn([],ao,((e,t)=>{e.emptyBoardContents()})),this._primitiveProcedures._FAIL=new zn([Kn],((e,t,r,s)=>{Hn(e,t,s[0].string,[])}),((e,t)=>{})),this._primitiveFunctions._makeRange=new zn([Yn,Yn],((e,t,r,s)=>{const n=s[0],o=s[1];So(e,t,n,o),To(e,t,n,mo()),To(e,t,o,mo())}),((e,t,r)=>{let s=t;if(eo(fo(s,r)))return new Dn([]);const n=[];for(;eo(go(s,r));)n.push(s),s=bo(s);return n.push(s),new Dn(n)})),this._primitiveFunctions.not=new zn([Qn()],ao,((e,t)=>Xn(!eo(t)))),this._primitiveFunctions["&&"]=new zn([Yn,Yn],ao,((e,t,r)=>{throw Error('The function "&&" should never be called')})),this._primitiveFunctions["||"]=new zn([Yn,Yn],ao,((e,t,r)=>{throw Error('The function "||" should never be called')})),this._primitiveFunctions._makeRangeWithSecond=new zn([Yn,Yn,Yn],((e,t,r,s)=>{const n=s[0],o=s[1],i=s[2];To(e,t,n,[Jn]),To(e,t,o,[Jn]),To(e,t,i,[Jn])}),((e,t,r,s)=>{const n=s.sub(t);if(n.lt(new Mn(1)))return new Dn([]);let o=t;const i=[];for(;o.le(r);)i.push(o),o=o.add(n);return new Dn(i)})),this._primitiveFunctions._unsafeListLength=new zn([Yn],ao,((e,t)=>new Mn(t.length()))),this._primitiveFunctions._unsafeListNth=new zn([Yn,Yn],ao,((e,t,r)=>t.elements[r.asNumber()])),this._primitiveFunctions[cn("PRIM:numStones")]=new zn([to()],ao,((e,t)=>e.numStones(so(t)))),this._primitiveFunctions[cn("PRIM:anyStones")]=new zn([to()],ao,((e,t)=>Xn(e.numStones(so(t)).gt(new Mn(0))))),this._primitiveFunctions[cn("PRIM:canMove")]=new zn([no()],ao,((e,t)=>Xn(e.canMove(io(t))))),this._primitiveFunctions[cn("PRIM:next")]=new zn([Yn],((e,t,r,s)=>{To(e,t,s[0],mo())}),((e,t)=>bo(t))),this._primitiveFunctions[cn("PRIM:prev")]=new zn([Yn],((e,t,r,s)=>{To(e,t,s[0],mo())}),((e,t)=>Po(t))),this._primitiveFunctions[cn("PRIM:opposite")]=new zn([Yn],((e,t,r,s)=>{To(e,t,s[0],po())}),((e,t)=>vo(t))),this._primitiveFunctions[cn("PRIM:minBool")]=new zn([],ao,(e=>Xn(!1))),this._primitiveFunctions[cn("PRIM:maxBool")]=new zn([],ao,(e=>Xn(!0))),this._primitiveFunctions[cn("PRIM:minColor")]=new zn([],ao,(e=>ro(Gn()[0]))),this._primitiveFunctions[cn("PRIM:maxColor")]=new zn([],ao,(e=>ro(Gn()[Gn().length-1]))),this._primitiveFunctions[cn("PRIM:minDir")]=new zn([],ao,(e=>oo(Un()[0]))),this._primitiveFunctions[cn("PRIM:maxDir")]=new zn([],ao,(e=>oo(Un()[Un().length-1]))),this._primitiveFunctions["+"]=new zn([Jn,Jn],ao,((e,t,r)=>t.add(r))),this._primitiveFunctions["-"]=new zn([Jn,Jn],ao,((e,t,r)=>t.sub(r))),this._primitiveFunctions["*"]=new zn([Jn,Jn],ao,((e,t,r)=>t.mul(r))),this._primitiveFunctions.div=new zn([Jn,Jn],((e,t,r,s)=>{s[1].eq(new Mn(0))&&Hn(e,t,"cannot-divide-by-zero",[])}),((e,t,r)=>t.div(r))),this._primitiveFunctions.mod=new zn([Jn,Jn],((e,t,r,s)=>{s[1].eq(new Mn(0))&&Hn(e,t,"cannot-divide-by-zero",[])}),((e,t,r)=>t.mod(r))),this._primitiveFunctions["^"]=new zn([Jn,Jn],((e,t,r,s)=>{s[1].lt(new Mn(0))&&Hn(e,t,"negative-exponent",[])}),((e,t,r)=>t.pow(r))),this._primitiveFunctions["-(unary)"]=new zn([Yn],((e,t,r,s)=>{To(e,t,s[0],po())}),((e,t)=>vo(t))),this._primitiveFunctions["=="]=new zn([Yn,Yn],((e,t,r,s)=>{So(e,t,s[0],s[1])}),((e,t,r)=>Xn(t.equal(r)))),this._primitiveFunctions["/="]=new zn([Yn,Yn],((e,t,r,s)=>{So(e,t,s[0],s[1])}),((e,t,r)=>Xn(!t.equal(r)))),this._primitiveFunctions["<="]=new zn([Yn,Yn],((e,t,r,s)=>{const n=s[0],o=s[1];So(e,t,n,o),To(e,t,n,mo()),To(e,t,o,mo())}),((e,t,r)=>function(e,t){return co(e)?Xn(e.le(t)):Xn(_o(e)<=_o(t))}(t,r))),this._primitiveFunctions[">="]=new zn([Yn,Yn],((e,t,r,s)=>{const n=s[0],o=s[1];So(e,t,n,o),To(e,t,n,mo()),To(e,t,o,mo())}),((e,t,r)=>function(e,t){return co(e)?Xn(e.ge(t)):Xn(_o(e)>=_o(t))}(t,r))),this._primitiveFunctions["<"]=new zn([Yn,Yn],((e,t,r,s)=>{const n=s[0],o=s[1];So(e,t,n,o),To(e,t,n,mo()),To(e,t,o,mo())}),((e,t,r)=>go(t,r))),this._primitiveFunctions[">"]=new zn([Yn,Yn],((e,t,r,s)=>{const n=s[0],o=s[1];So(e,t,n,o),To(e,t,n,mo()),To(e,t,o,mo())}),((e,t,r)=>fo(t,r))),this._primitiveProcedures[cn("PRIM:BOOM")]=new zn([Kn],((e,t,r,s)=>{Hn(e,t,"boom-called",[s[0].string])}),((e,t)=>{throw Error("Should not be reachable.")})),this._primitiveFunctions[cn("PRIM:boom")]=this._primitiveProcedures[cn("PRIM:BOOM")],this._primitiveFunctions["++"]=new zn([Zn,Zn],((e,t,r,s)=>{So(e,t,s[0],s[1])}),((e,t,r)=>t.append(r))),this._primitiveFunctions[cn("PRIM:isEmpty")]=new zn([Zn],ao,((e,t)=>Xn(0===t.length()))),this._primitiveFunctions[cn("PRIM:head")]=new zn([Zn],((e,t,r,s)=>{0===s[0].length()&&Hn(e,t,"list-cannot-be-empty",[])}),((e,t)=>t.head())),this._primitiveFunctions[cn("PRIM:tail")]=new zn([Zn],((e,t,r,s)=>{0===s[0].length()&&Hn(e,t,"list-cannot-be-empty",[])}),((e,t)=>t.tail())),this._primitiveFunctions[cn("PRIM:oldTail")]=this._primitiveFunctions[cn("PRIM:tail")],this._primitiveFunctions[cn("PRIM:init")]=new zn([Zn],((e,t,r,s)=>{0===s[0].length()&&Hn(e,t,"list-cannot-be-empty",[])}),((e,t)=>t.init())),this._primitiveFunctions[cn("PRIM:last")]=new zn([Zn],((e,t,r,s)=>{0===s[0].length()&&Hn(e,t,"list-cannot-be-empty",[])}),((e,t)=>t.last()))}types(){const e=[];for(const t in this._primitiveTypes)e.push(t);return e}typeConstructors(e){if(!(e in this._primitiveTypes))throw Error("Not a primitive type: "+e);const t=[];for(const r in this._primitiveTypes[e])t.push(r);return t}constructorFields(e,t){if(!(e in this._primitiveTypes))throw Error("Not a primitive type: "+e);if(!(t in this._primitiveTypes[e]))throw Error("Not a primitive constructor: "+t);return this._primitiveTypes[e][t]}isOperation(e){return e in this._primitiveProcedures||e in this._primitiveFunctions}getOperation(e){if(e in this._primitiveProcedures)return this._primitiveProcedures[e];if(e in this._primitiveFunctions)return this._primitiveFunctions[e];throw Error(e+" is not a primitive.")}procedures(){const e=[];for(const t in this._primitiveProcedures)e.push(t);return e}isProcedure(e){return e in this._primitiveProcedures}functions(){const e=[];for(const t in this._primitiveFunctions)e.push(t);return e}isFunction(e){return e in this._primitiveFunctions}}class Eo{constructor(e){this._symtable=e,this._code=new vs([]),this._nextLabel=0,this._nextVariable=0,this._primitives=new yo}compile(e){return this._compileMain(e),this._code}_compileMain(e){if(0!==e.definitions.length){for(const t of e.definitions)t.tag===Oe?this._compileDefProgram(t):t.tag===ke&&this._compileDefInteractiveProgram(t);for(const t of e.definitions)t.tag===Ie?this._compileDefProcedure(t):t.tag===Re&&this._compileDefFunction(t)}else this._produce(e.startPos,e.endPos,new As)}_compileDefProgram(e){this._compileStatement(e.body),this._produce(e.startPos,e.endPos,new As)}_compileDefInteractiveProgram(e){this._compileMatchBranches(e,!1),this._produce(e.startPos,e.endPos,new As)}_compileDefProcedure(e){this._produce(e.startPos,e.endPos,new Ns(e.name.value));for(const t of e.parameters){const r=t.value;this._produce(e.startPos,e.endPos,new xs(r))}this._compileStatement(e.body),this._produce(e.startPos,e.endPos,new As)}_compileDefFunction(e){this._produceList(e.startPos,e.endPos,[new Ns(e.name.value),new Ws]);for(const t of e.parameters){const r=t.value;this._produce(e.startPos,e.endPos,new xs(r))}this._compileStatement(e.body),this._produceList(e.startPos,e.endPos,[new qs,new As])}_compileStatement(e){switch(e.tag){case Ae:return this._compileStmtBlock(e);case Me:return this._compileStmtReturn(e);case Fe:return this._compileStmtIf(e);case Be:return this._compileStmtRepeat(e);case De:return this._compileStmtForeach(e);case Ve:return this._compileStmtWhile(e);case He:return this._compileStmtSwitch(e);case Ge:return this._compileStmtAssignVariable(e);case Ue:return this._compileStmtAssignTuple(e);case $e:return this._compileStmtProcedureCall(e);default:throw Error("Compiler: Statement not implemented: "+Symbol.keyFor(e.tag))}}_compileStmtBlock(e){for(const t of e.statements)this._compileStatement(t)}_compileStmtReturn(e){return this._compileExpression(e.result)}_compileStmtIf(e){this._compileExpression(e.condition),this._produce(e.condition.startPos,e.condition.endPos,new zs(new Sn(cn("TYPE:Bool"),{})));const t=this._freshLabel();if(this._produce(e.startPos,e.endPos,new ks(t)),this._compileStatement(e.thenBlock),void 0===e.elseBlock)this._produce(e.startPos,e.endPos,new Ns(t));else{const r=this._freshLabel();this._produceList(e.startPos,e.endPos,[new Os(r),new Ns(t)]),this._compileStatement(e.elseBlock),this._produce(e.startPos,e.endPos,new Ns(r))}}_compileStmtRepeat(e){this._compileExpression(e.times),this._produce(e.times.startPos,e.times.endPos,new zs(new bn));const t=this._freshLabel(),r=this._freshLabel();this._produceList(e.startPos,e.endPos,[new Ns(t),new Us,new ys(0),new js(">",2),new ks(r)]),this._compileStatement(e.body),this._produceList(e.startPos,e.endPos,[new ys(1),new js("-",2),new Os(t),new Ns(r),new $s])}_compileStmtForeach(e){const t=this._freshLabel(),r=this._freshLabel(),s=this._freshVariable(),n=this._freshVariable(),o=this._freshVariable();this._compileExpression(e.range),this._produceList(e.range.startPos,e.range.endPos,[new zs(new Tn(new fn)),new xs(s),new ws(s),new js("_unsafeListLength",1),new xs(o)]),this._produceList(e.startPos,e.endPos,[new ys(0),new xs(n),new Ns(t),new ws(n),new ws(o),new js("<",2),new ks(r),new ws(s),new ws(n),new js("_unsafeListNth",2)]),this._compileMatchForeachPatternOrFail(e.pattern),this._compileStatement(e.body),this._produceList(e.startPos,e.endPos,[new ws(n),new ys(1),new js("+",2),new xs(n),new Os(t),new Ns(r),new Cs(s),new Cs(o),new Cs(n)]),this._compilePatternUnbind(e.pattern)}_compileMatchForeachPatternOrFail(e){switch(e.tag){case je:return void this._produce(e.startPos,e.endPos,new $s);case We:{const t=e;return void this._produce(e.startPos,e.endPos,new xs(t.variableName.value))}default:{const t=this._freshLabel();return this._compilePatternCheck(e,t),this._produceList(e.startPos,e.endPos,[new Es("foreach-pattern-does-not-match"),new js("_FAIL",1),new Ns(t)]),this._compilePatternBind(e),void this._produce(e.startPos,e.endPos,new $s)}}}_compileStmtWhile(e){const t=this._freshLabel(),r=this._freshLabel();this._produce(e.startPos,e.endPos,new Ns(t)),this._compileExpression(e.condition),this._produceList(e.startPos,e.endPos,[new zs(new Sn(cn("TYPE:Bool"),{})),new ks(r)]),this._compileStatement(e.body),this._produceList(e.startPos,e.endPos,[new Os(t),new Ns(r)])}_compileStmtSwitch(e){this._compileExpression(e.subject),this._compileMatchBranches(e,!1)}_compileMatchBranches(e,t){const r=[];for(const t of e.branches){const e=this._freshLabel();r.push(e),this._compilePatternCheck(t.pattern,e)}this._produceList(e.startPos,e.endPos,[new Es("switch-does-not-match"),new js("_FAIL",1)]);const s=this._freshLabel();for(let n=0;n<r.length;n++){const o=e.branches[n],i=r[n];this._produce(o.startPos,o.endPos,new Ns(i)),this._compilePatternBind(o.pattern),this._produce(o.startPos,o.endPos,new $s),t?this._compileExpression(o.body):this._compileStatement(o.body),this._compilePatternUnbind(o.pattern),this._produce(o.startPos,o.endPos,new Os(s))}this._produce(e.startPos,e.endPos,new Ns(s))}_compileStmtAssignVariable(e){this._compileExpression(e.value),this._produce(e.startPos,e.endPos,new xs(e.variable.value))}_compileStmtAssignTuple(e){this._compileExpression(e.value);const t=[];for(const r of e.variables)t.push(new fn);const r=new vn(t);this._produce(e.startPos,e.endPos,new zs(r));for(let t=0;t<e.variables.length;t++)this._produceList(e.startPos,e.endPos,[new Vs(t),new xs(e.variables[t].value)]);this._produce(e.startPos,e.endPos,new $s)}_compileStmtProcedureCall(e){const t=e.procedureName.value;for(const t of e.args)this._compileExpression(t);if(this._primitives.isProcedure(t))this._compileStmtProcedureCallPrimitive(e);else{if(!this._symtable.isProcedure(t))throw Error("Compiler: "+t+" is an undefined procedure.");this._compileStmtProcedureCallUserDefined(e)}}_compileStmtProcedureCallPrimitive(e){this._produce(e.startPos,e.endPos,new js(e.procedureName.value,e.args.length))}_compileStmtProcedureCallUserDefined(e){this._produce(e.startPos,e.endPos,new Ls(e.procedureName.value,e.args.length))}_compilePatternCheck(e,t){switch(e.tag){case je:return this._compilePatternCheckWildcard(e,t);case We:return this._compilePatternCheckVariable(e,t);case qe:return this._compilePatternCheckNumber(e,t);case ze:return this._compilePatternCheckStructure(e,t);case Ye:return this._compilePatternCheckTuple(e,t);case Je:return this._compilePatternCheckTimeout(e,t);default:throw Error("Compiler: Pattern check not implemented: "+Symbol.keyFor(e.tag))}}_compilePatternCheckWildcard(e,t){this._produce(e.startPos,e.endPos,new Os(t))}_compilePatternCheckVariable(e,t){this._produce(e.startPos,e.endPos,new Os(t))}_compilePatternCheckNumber(e,t){this._produceList(e.startPos,e.endPos,[new Us,new zs(new bn),new ys(parseInt(e.number.value,10)),new js("/=",2),new ks(t)])}_compilePatternCheckStructure(e,t){const r=e.constructorName.value,s=this._symtable.constructorType(r),n=new Sn(s,{});this._produce(e.startPos,e.endPos,new zs(n)),this._produce(e.startPos,e.endPos,new Is(r,t))}_compilePatternCheckTuple(e,t){const r=[];for(const t of e.boundVariables)r.push(new fn);const s=new vn(r);this._produce(e.startPos,e.endPos,new zs(s)),this._produce(e.startPos,e.endPos,new Rs(e.boundVariables.length,t))}_compilePatternCheckTimeout(e,t){this._produce(e.startPos,e.endPos,new Is(cn("CONS:TIMEOUT"),t))}_compilePatternBind(e){switch(e.tag){case je:return;case We:return void this._compilePatternBindVariable(e);case qe:return;case ze:return void this._compilePatternBindStructure(e);case Ye:return void this._compilePatternBindTuple(e);case Je:return;default:throw Error("Compiler: Pattern binding not implemented: "+Symbol.keyFor(e.tag))}}_compilePatternBindVariable(e){this._produceList(e.startPos,e.endPos,[new Us,new xs(e.variableName.value)])}_compilePatternBindStructure(e){if(0===e.boundVariables.length)return;const t=e.constructorName.value,r=this._symtable.constructorFields(t);for(let t=0;t<r.length;t++){const s=e.boundVariables[t],n=r[t];this._produceList(e.startPos,e.endPos,[new Hs(n),new xs(s.value)])}}_compilePatternBindTuple(e){for(let t=0;t<e.boundVariables.length;t++){const r=e.boundVariables[t];this._produceList(e.startPos,e.endPos,[new Vs(t),new xs(r.value)])}}_compilePatternUnbind(e){for(const t of e.boundVariables)this._produceList(e.startPos,e.endPos,[new Cs(t.value)])}_compileExpression(e){switch(e.tag){case Ke:return this._compileExprVariable(e);case Qe:return this._compileExprConstantNumber(e);case Ze:return this._compileExprConstantString(e);case Xe:return this._compileExprChoose(e);case et:return this._compileExprMatching(e);case tt:return this._compileExprList(e);case rt:return this._compileExprRange(e);case st:return this._compileExprTuple(e);case nt:return this._compileExprStructure(e);case ot:return this._compileExprStructureUpdate(e);case it:return this._compileExprFunctionCall(e);default:throw Error("Compiler: Expression not implemented: "+Symbol.keyFor(e.tag))}}_compileExprVariable(e){this._produce(e.startPos,e.endPos,new ws(e.variableName.value))}_compileExprConstantNumber(e){this._produce(e.startPos,e.endPos,new ys(parseInt(e.number.value,10)))}_compileExprConstantString(e){this._produce(e.startPos,e.endPos,new Es(e.string.value))}_compileExprChoose(e){this._compileExpression(e.condition),this._produce(e.condition.startPos,e.condition.endPos,new zs(new Sn(cn("TYPE:Bool"),{})));const t=this._freshLabel();this._produce(e.startPos,e.endPos,new ks(t)),this._compileExpression(e.trueExpr);const r=this._freshLabel();this._produceList(e.startPos,e.endPos,[new Os(r),new Ns(t)]),this._compileExpression(e.falseExpr),this._produce(e.startPos,e.endPos,new Ns(r))}_compileExprMatching(e){this._compileExpression(e.subject),this._compileMatchBranches(e,!0)}_compileExprList(e){for(const t of e.elements)this._compileExpression(t);this._produce(e.startPos,e.endPos,new Fs(e.elements.length))}_compileExprRange(e){this._compileExpression(e.first),this._compileExpression(e.last),void 0===e.second?this._produce(e.startPos,e.endPos,new js("_makeRange",2)):(this._compileExpression(e.second),this._produce(e.startPos,e.endPos,new js("_makeRangeWithSecond",3)))}_compileExprTuple(e){for(const t of e.elements)this._compileExpression(t);this._produce(e.startPos,e.endPos,new Ms(e.elements.length))}_compileExprStructure(e){const t=[];for(const r of e.fieldBindings)this._compileExpression(r.value),t.push(r.fieldName.value);const r=e.constructorName.value,s=this._symtable.constructorType(r);this._produce(e.startPos,e.endPos,new Bs(s,r,t))}_compileExprStructureUpdate(e){this._compileExpression(e.original);const t=[];for(const r of e.fieldBindings)this._compileExpression(r.value),t.push(r.fieldName.value);const r=e.constructorName.value,s=this._symtable.constructorType(r);this._produce(e.startPos,e.endPos,new Ds(s,r,t))}_compileExprFunctionCall(e){const t=e.functionName.value;if("&&"===t)this._compileExprFunctionCallAnd(e);else if("||"===t)this._compileExprFunctionCallOr(e);else{for(const t of e.args)this._compileExpression(t);if(this._primitives.isFunction(t))this._compileExprFunctionCallPrimitive(e);else if(this._symtable.isFunction(t))this._compileExprFunctionCallUserDefined(e);else{if(!this._symtable.isField(t))throw Error("Compiler: "+t+" is an undefined function.");this._compileExprFunctionCallFieldAccessor(e)}}}_compileExprFunctionCallAnd(e){const t=e.args[0],r=e.args[1],s=this._freshLabel();this._compileExpression(t),this._produceList(e.startPos,e.endPos,[new zs(new Sn(cn("TYPE:Bool"),{})),new Is(cn("CONS:False"),s),new $s]),this._compileExpression(r),this._produceList(e.startPos,e.endPos,[new zs(new Sn(cn("TYPE:Bool"),{})),new Ns(s)])}_compileExprFunctionCallOr(e){const t=e.args[0],r=e.args[1],s=this._freshLabel();this._compileExpression(t),this._produceList(e.startPos,e.endPos,[new zs(new Sn(cn("TYPE:Bool"),{})),new Is(cn("CONS:True"),s),new $s]),this._compileExpression(r),this._produceList(e.startPos,e.endPos,[new zs(new Sn(cn("TYPE:Bool"),{})),new Ns(s)])}_compileExprFunctionCallPrimitive(e){this._produce(e.startPos,e.endPos,new js(e.functionName.value,e.args.length))}_compileExprFunctionCallUserDefined(e){this._produce(e.startPos,e.endPos,new Ls(e.functionName.value,e.args.length))}_compileExprFunctionCallFieldAccessor(e){this._produceList(e.startPos,e.endPos,[new Gs(e.functionName.value)])}_produce(e,t,r){r.startPos=e,r.endPos=t,this._code.produce(r)}_produceList(e,t,r){for(const s of r)this._produce(e,t,s)}_freshLabel(){const e="_l"+this._nextLabel.toString();return this._nextLabel++,e}_freshVariable(){const e="_v"+this._nextVariable.toString();return this._nextVariable++,e}}const wo=Symbol.for("RT_ExitProgram");class xo extends Error{constructor(e){super(Symbol.keyFor(e)),this.tag=e}}class Co extends xo{constructor(e){super(wo),this.returnValue=e}}function No(e,t,r,s){throw new Pr(e,t,r,s)}class Oo{constructor(e,t,r){this._routineName=t,this._instructionPointer=r,this._variableTypes={},this._variables={},this._stack=[],this._uniqueFrameId=e}get routineName(){return this._routineName}get uniqueFrameId(){return this._uniqueFrameId}get instructionPointer(){return this._instructionPointer}set instructionPointer(e){this._instructionPointer=e}setVariable(e,t,r){this._variableTypes[e]=t,this._variables[e]=r}unsetVariable(e){delete this._variables[e]}getVariableType(e){return e in this._variableTypes?this._variableTypes[e]:new fn}getVariable(e){return e in this._variables?this._variables[e]:void 0}stackEmpty(){return 0===this._stack.length}pushValue(e){this._stack.push(e)}stackTop(){if(0===this._stack.length)throw Error("VM: no value at the top of the stack; the stack is empty.");return this._stack[this._stack.length-1]}popValue(){if(0===this._stack.length)throw Error("VM: no value to pop; the stack is empty.");return this._stack.pop()}}class ko{constructor(e,t){this._code=e,this._labelTargets=this._code.labelTargets(),this._nextFrameId=0,this._callStack=[],this._callStack.push(this._newFrame("program",0)),this._globalStateStack=[t],this._primitives=new yo,this._snapshotCallback=void 0}run(){return this.runWithTimeout(0)}runWithTimeout(e){return this.runWithTimeoutTakingSnapshots(e,void 0)}runEventWithTimeout(e,t){return this._callStack=[this._newFrame("program",0)],this._currentFrame().pushValue(e),this.runWithTimeout(t)}runWithTimeoutTakingSnapshots(e,t){const r=(new Date).getTime();this._snapshotCallback=t,this._takeSnapshot("program");try{for(;;)this._step(),this._timeoutIfNeeded(r,e)}catch(e){if(e.tag===wo)return e.returnValue;throw e}}_newFrame(e,t){const r=this._nextFrameId;return this._nextFrameId++,new Oo(r,e,t)}_timeoutIfNeeded(e,t){if(t>0&&(new Date).getTime()-e>t){const e=this._currentInstruction();No(e.startPos,e.endPos,"timeout",[t])}}_takeSnapshot(e){if(void 0!==this._snapshotCallback){const t=this._currentInstruction();this._snapshotCallback(e,t.startPos,this._callStack,this.globalState())}}globalState(){return this._globalStateStack[this._globalStateStack.length-1]}setGlobalState(e){this._globalStateStack[this._globalStateStack.length-1]=e}_currentFrame(){return this._callStack[this._callStack.length-1]}_currentInstruction(){return this._code.at(this._currentFrame().instructionPointer)}_step(){switch(this._currentInstruction().opcode){case Yr:return this._stepPushInteger();case Jr:return this._stepPushString();case Kr:return this._stepPushVariable();case Qr:return this._stepSetVariable();case Zr:return this._stepUnsetVariable();case Xr:return this._stepLabel();case es:return this._stepJump();case ts:return this._stepJumpIfFalse();case rs:return this._stepJumpIfStructure();case ss:return this._stepJumpIfTuple();case ns:return this._stepCall();case os:return this._stepReturn();case is:return this._stepMakeTuple();case as:return this._stepMakeList();case cs:return this._stepMakeStructure();case us:return this._stepUpdateStructure();case ls:return this._stepReadTupleComponent();case hs:return this._stepReadStructureField();case ps:return this._stepReadStructureFieldPop();case ms:return this._stepAdd();case ds:return this._stepDup();case _s:return this._stepPop();case gs:return this._stepPrimitiveCall();case fs:return this._stepSaveState();case bs:return this._stepRestoreState();case Ps:return this._stepTypeCheck();default:throw Error("VM: opcode "+Symbol.keyFor(this._currentInstruction().opcode)+" not implemented")}}_stepPushInteger(){const e=this._currentFrame(),t=this._currentInstruction();e.pushValue(new Mn(t.number)),e.instructionPointer++}_stepPushString(){const e=this._currentFrame(),t=this._currentInstruction();e.pushValue(new Fn(t.string)),e.instructionPointer++}_stepPushVariable(){const e=this._currentFrame(),t=this._currentInstruction(),r=e.getVariable(t.variableName);void 0===r&&No(t.startPos,t.endPos,"undefined-variable",[t.variableName]),e.pushValue(r),e.instructionPointer++}_stepSetVariable(){const e=this._currentFrame(),t=this._currentInstruction(),r=e.popValue(),s=e.getVariableType(t.variableName),n=r.type(),o=yn(s,n);void 0===o&&No(t.startPos,t.endPos,"incompatible-types-on-assignment",[t.variableName,s,n]),e.setVariable(t.variableName,o,r),e.instructionPointer++}_stepUnsetVariable(){const e=this._currentFrame(),t=this._currentInstruction();e.unsetVariable(t.variableName),e.instructionPointer++}_stepLabel(){this._currentFrame().instructionPointer++}_stepJump(){const e=this._currentFrame(),t=this._currentInstruction();e.instructionPointer=this._labelTargets[t.targetLabel]}_stepJumpIfFalse(){const e=this._currentFrame(),t=this._currentInstruction(),r=e.popValue();r.tag===Ln&&"False"===r.constructorName?e.instructionPointer=this._labelTargets[t.targetLabel]:e.instructionPointer++}_stepJumpIfStructure(){const e=this._currentFrame(),t=this._currentInstruction(),r=e.stackTop();r.tag===Ln&&r.constructorName===t.constructorName?e.instructionPointer=this._labelTargets[t.targetLabel]:e.instructionPointer++}_stepJumpIfTuple(){const e=this._currentFrame(),t=this._currentInstruction(),r=e.stackTop();r.tag===In&&r.size()===t.size?e.instructionPointer=this._labelTargets[t.targetLabel]:e.instructionPointer++}_stepCall(){const e=this._currentFrame(),t=this._currentInstruction(),r=this._newFrame(t.targetLabel,this._labelTargets[t.targetLabel]);this._callStack.push(r);for(let s=0;s<t.nargs;s++)e.stackEmpty()&&No(t.startPos,t.endPos,"too-few-arguments",[t.targetLabel]),r.pushValue(e.popValue())}_stepReturn(){const e=this._currentFrame();let t;if(e.stackEmpty())t=void 0;else if(this._takeSnapshot(e.routineName),t=e.popValue(),!e.stackEmpty())throw Error("VM: stack should be empty");if(this._callStack.pop(),0===this._callStack.length)throw new Co(t);{const e=this._currentFrame();void 0!==t&&e.pushValue(t),e.instructionPointer++}}_stepMakeTuple(){const e=this._currentFrame(),t=this._currentInstruction(),r=[];for(let s=0;s<t.size;s++)r.unshift(e.popValue());e.pushValue(new Bn(r)),e.instructionPointer++}_stepMakeList(){const e=this._currentFrame(),t=this._currentInstruction(),r=[];for(let s=0;s<t.size;s++)r.unshift(e.popValue());let s=new fn,n=0;for(const e of r){const r=s,o=e.type();s=yn(r,o),void 0===s&&No(t.startPos,t.endPos,"incompatible-types-on-list-creation",[n,r,o]),n++}e.pushValue(new Dn(r)),e.instructionPointer++}_stepMakeStructure(){const e=this._currentFrame(),t=this._currentInstruction(),r={},s=t.fieldNames.length;for(let n=0;n<s;n++){r[t.fieldNames[s-n-1]]=e.popValue()}e.pushValue(new Vn(t.typeName,t.constructorName,r)),e.instructionPointer++}_stepUpdateStructure(){const e=this._currentFrame(),t=this._currentInstruction(),r={},s=[],n=t.fieldNames.length;for(let o=0;o<n;o++){const i=t.fieldNames[n-o-1];r[i]=e.popValue(),s.unshift(i)}const o=e.popValue();if(o.tag!==Ln&&No(t.startPos,t.endPos,"expected-structure-but-got",[t.constructorName,cn(Symbol.keyFor(o.tag))]),o.constructorName!==t.constructorName&&No(t.startPos,t.endPos,"expected-constructor-but-got",[t.constructorName,o.constructorName]),o.typeName!==t.typeName)throw Error("VM: UpdateStructure instruction does not match type.");for(const e of s){const s=o.fields[e].type(),n=r[e].type();void 0===yn(s,n)&&No(t.startPos,t.endPos,"incompatible-types-on-structure-update",[e,s,n])}e.pushValue(o.updateFields(r)),e.instructionPointer++}_stepReadTupleComponent(){const e=this._currentFrame(),t=this._currentInstruction(),r=e.stackTop();r.tag!==In&&No(t.startPos,t.endPos,"expected-tuple-value-but-got",[r.type()]),t.index>=r.size()&&No(t.startPos,t.endPos,"tuple-component-out-of-bounds",[r.size(),t.index]),e.pushValue(r.components[t.index]),e.instructionPointer++}_stepReadStructureFieldGeneric(e){const t=this._currentFrame(),r=this._currentInstruction();let s;s=e?t.popValue():t.stackTop(),s.tag!==Ln&&No(r.startPos,r.endPos,"expected-structure-value-but-got",[s.type()]),r.fieldName in s.fields||No(r.startPos,r.endPos,"structure-field-not-present",[s.fieldNames(),r.fieldName]),t.pushValue(s.fields[r.fieldName]),t.instructionPointer++}_stepReadStructureField(){this._stepReadStructureFieldGeneric(!1)}_stepReadStructureFieldPop(){this._stepReadStructureFieldGeneric(!0)}_stepAdd(){const e=this._currentFrame(),t=e.popValue(),r=e.popValue();e.pushValue(t.add(r)),e.instructionPointer++}_stepDup(){const e=this._currentFrame(),t=e.popValue();e.pushValue(t),e.pushValue(t),e.instructionPointer++}_stepPop(){const e=this._currentFrame();e.popValue(),e.instructionPointer++}_stepPrimitiveCall(){const e=this._currentFrame(),t=this._currentInstruction(),r=[];for(let s=0;s<t.nargs;s++)r.unshift(e.popValue());this._primitives.isOperation(t.primitiveName)||No(t.startPos,t.endPos,"primitive-does-not-exist",[t.primitiveName]);const s=this._primitives.getOperation(t.primitiveName);s.argumentTypes.length!==t.nargs&&No(t.startPos,t.endPos,"primitive-arity-mismatch",[t.primitiveName,s.argumentTypes.length,t.nargs]);for(let e=0;e<t.nargs;e++){const n=s.argumentTypes[e],o=r[e].type();void 0===yn(n,o)&&No(t.startPos,t.endPos,"primitive-argument-type-mismatch",[t.primitiveName,e+1,t.nargs,n,o])}s.validateArguments(t.startPos,t.endPos,this.globalState(),r);const n=s.call(this.globalState(),r);void 0!==n&&e.pushValue(n),this._takeSnapshot(t.primitiveName),e.instructionPointer++}_stepSaveState(){const e=this._currentFrame();this._globalStateStack.push(this.globalState().clone()),e.instructionPointer++}_stepRestoreState(){const e=this._currentFrame();if(this._globalStateStack.pop(),0===this._globalStateStack.length)throw Error("RestoreState: the stack of global states is empty.");e.instructionPointer++}_stepTypeCheck(){const e=this._currentFrame(),t=this._currentInstruction(),r=t.type,s=e.stackTop().type();void 0===yn(r,s)&&No(t.startPos,t.endPos,"expected-value-of-type-but-got",[r,s]),e.instructionPointer++}regionStack(){const e=[];for(const t of this._callStack){const r=this._code.at(t.instructionPointer);e.push(r.startPos.region)}return e}}const Io=(e,t)=>new Ce(e,t,d,d);class Ro{constructor(){this.initialize()}initialize(){this._ast=void 0,this._primitives=new yo,this._symtable=this._newSymtableWithPrimitives(),this._linter=new Or(this._symtable),this._code=void 0,this._vm=void 0,this._result=void 0}run(e){return this.runState(e,new qn).result}runState(e,t){return this.parse(e),this.lint(),this.compile(),this.execute(t),{result:this._result,state:this._vm.globalState()}}parse(e){const t=new zr(e);this._ast=t.parse();for(const e of t.getLanguageOptions())this._setLanguageOption(e)}enableLintCheck(e,t){this._linter.enableCheck(e,t)}lint(){this._symtable=this._linter.lint(this._ast)}compile(){this._code=new Eo(this._symtable).compile(this._ast)}initializeVirtualMachine(e){this._vm=new ko(this._code,e)}execute(e){this.executeWithTimeout(e,0)}executeWithTimeout(e,t){this.executeWithTimeoutTakingSnapshots(e,t,void 0)}executeWithTimeoutTakingSnapshots(e,t,r){this.initializeVirtualMachine(e),this._result=this._vm.runWithTimeoutTakingSnapshots(t,r)}executeEventWithTimeout(e,t){this._result=this._vm.runEventWithTimeout(e,t)}get abstractSyntaxTree(){return this._ast}get primitives(){return this._primitives}get symbolTable(){return this._symtable}get virtualMachineCode(){return this._code}get result(){return this._result}get globalState(){return this._vm.globalState()}_setLanguageOption(e){if("DestructuringForeach"===e)this.enableLintCheck("forbidden-extension-destructuring-foreach",!1);else{if("AllowRecursion"!==e)throw Error("Unknown language option: "+e);this.enableLintCheck("forbidden-extension-allow-recursion",!1)}}regionStack(){return this._vm.regionStack()}_newSymtableWithPrimitives(){const e=new xr;for(const t of this._primitives.types())e.defType(this._astDefType(t));for(const t of this._primitives.procedures())e.defProcedure(this._astDefProcedure(t));for(const t of this._primitives.functions())e.defFunction(this._astDefFunction(t));return e}_astDefType(e){const t=[];for(const r of this._primitives.typeConstructors(e))t.push(this._astConstructorDeclaration(e,r));return new Tt(Io(P,e),t)}_astDefProcedure(e){const t=this._primitives.getOperation(e).nargs(),r=[];for(let e=1;e<=t;e++)r.push(Io(v,"x"+e.toString()));return new Pt(Io(v,e),r,new St([]))}_astDefFunction(e){const t=this._primitives.getOperation(e).nargs(),r=[];for(let e=1;e<=t;e++)r.push(Io(v,"x"+e.toString()));return new vt(Io(v,e),r,new St([]))}_astConstructorDeclaration(e,t){const r=[];for(const s of this._primitives.constructorFields(e,t))r.push(Io(v,s));return new Xt(Io(P,t),r)}}var Lo,Ao=(function(e,t){const r=i.default.EventEmitter;class s{constructor(){this.helpWidth=void 0,this.sortSubcommands=!1,this.sortOptions=!1}visibleCommands(e){const t=e.commands.filter((e=>!e._hidden));if(e._hasImplicitHelpCommand()){const r=e._helpCommandnameAndArgs.split(/ +/),s=e.createCommand(r.shift()).helpOption(!1);s.description(e._helpCommandDescription),s._parseExpectedArgs(r),t.push(s)}return this.sortSubcommands&&t.sort(((e,t)=>e.name().localeCompare(t.name()))),t}visibleOptions(e){const t=e.options.filter((e=>!e.hidden)),r=e._hasHelpOption&&e._helpShortFlag&&!e._findOption(e._helpShortFlag),s=e._hasHelpOption&&!e._findOption(e._helpLongFlag);if(r||s){let n;n=r?s?e.createOption(e._helpFlags,e._helpDescription):e.createOption(e._helpShortFlag,e._helpDescription):e.createOption(e._helpLongFlag,e._helpDescription),t.push(n)}if(this.sortOptions){const e=e=>e.short?e.short.replace(/^-/,""):e.long.replace(/^--/,"");t.sort(((t,r)=>e(t).localeCompare(e(r))))}return t}visibleArguments(e){return e._argsDescription&&e._args.length?e._args.map((t=>({term:t.name,description:e._argsDescription[t.name]||""})),0):[]}subcommandTerm(e){const t=e._args.map((e=>m(e))).join(" ");return e._name+(e._aliases[0]?"|"+e._aliases[0]:"")+(e.options.length?" [options]":"")+(t?" "+t:"")}optionTerm(e){return e.flags}longestSubcommandTermLength(e,t){return t.visibleCommands(e).reduce(((e,r)=>Math.max(e,t.subcommandTerm(r).length)),0)}longestOptionTermLength(e,t){return t.visibleOptions(e).reduce(((e,r)=>Math.max(e,t.optionTerm(r).length)),0)}longestArgumentTermLength(e,t){return t.visibleArguments(e).reduce(((e,t)=>Math.max(e,t.term.length)),0)}commandUsage(e){let t=e._name;e._aliases[0]&&(t=t+"|"+e._aliases[0]);let r="";for(let t=e.parent;t;t=t.parent)r=t.name()+" "+r;return r+t+" "+e.usage()}commandDescription(e){return e.description()}subcommandDescription(e){return e.description()}optionDescription(e){if(e.negate)return e.description;const t=[];return e.argChoices&&t.push(`choices: ${e.argChoices.map((e=>JSON.stringify(e))).join(", ")}`),void 0!==e.defaultValue&&t.push(`default: ${e.defaultValueDescription||JSON.stringify(e.defaultValue)}`),t.length>0?`${e.description} (${t.join(", ")})`:e.description}formatHelp(e,t){const r=t.padWidth(e,t),s=t.helpWidth||80;function n(e,n){if(n){const o=`${e.padEnd(r+2)}${n}`;return t.wrap(o,s-2,r+2)}return e}function o(e){return e.join("\n").replace(/^/gm," ".repeat(2))}let i=[`Usage: ${t.commandUsage(e)}`,""];const a=t.commandDescription(e);a.length>0&&(i=i.concat([a,""]));const c=t.visibleArguments(e).map((e=>n(e.term,e.description)));c.length>0&&(i=i.concat(["Arguments:",o(c),""]));const u=t.visibleOptions(e).map((e=>n(t.optionTerm(e),t.optionDescription(e))));u.length>0&&(i=i.concat(["Options:",o(u),""]));const l=t.visibleCommands(e).map((e=>n(t.subcommandTerm(e),t.subcommandDescription(e))));return l.length>0&&(i=i.concat(["Commands:",o(l),""])),i.join("\n")}padWidth(e,t){return Math.max(t.longestOptionTermLength(e,t),t.longestSubcommandTermLength(e,t),t.longestArgumentTermLength(e,t))}wrap(e,t,r,s=40){if(e.match(/[\n]\s+/))return e;const n=t-r;if(n<s)return e;const o=e.substr(0,r),i=e.substr(r),a=" ".repeat(r),c=new RegExp(".{1,"+(n-1)+"}([\\s​]|$)|[^\\s​]+?([\\s​]|$)","g");return o+(i.match(c)||[]).map(((e,t)=>("\n"===e.slice(-1)&&(e=e.slice(0,e.length-1)),(t>0?a:"")+e.trimRight()))).join("\n")}}class n{constructor(e,t){this.flags=e,this.description=t||"",this.required=e.includes("<"),this.optional=e.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(e),this.mandatory=!1;const r=d(e);this.short=r.shortFlag,this.long=r.longFlag,this.negate=!1,this.long&&(this.negate=this.long.startsWith("--no-")),this.defaultValue=void 0,this.defaultValueDescription=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0}default(e,t){return this.defaultValue=e,this.defaultValueDescription=t,this}argParser(e){return this.parseArg=e,this}makeOptionMandatory(e=!0){return this.mandatory=!!e,this}hideHelp(e=!0){return this.hidden=!!e,this}choices(e){return this.argChoices=e,this.parseArg=t=>{if(!e.includes(t))throw new l(`Allowed choices are ${e.join(", ")}.`);return t},this}name(){return this.long?this.long.replace(/^--/,""):this.short.replace(/^-/,"")}attributeName(){return this.name().replace(/^no-/,"").split("-").reduce(((e,t)=>e+t[0].toUpperCase()+t.slice(1)))}is(e){return this.short===e||this.long===e}}class u extends Error{constructor(e,t,r){super(r),Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=t,this.exitCode=e,this.nestedError=void 0}}class l extends u{constructor(e){super(1,"commander.invalidOptionArgument",e),Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}class h extends r{constructor(e){super(),this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!0,this._args=[],this.rawArgs=null,this._scriptPath=null,this._name=e||"",this._optionValues={},this._storeOptionsAsProperties=!1,this._actionResults=[],this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._outputConfiguration={writeOut:e=>process.stdout.write(e),writeErr:e=>process.stderr.write(e),getOutHelpWidth:()=>process.stdout.isTTY?process.stdout.columns:void 0,getErrHelpWidth:()=>process.stderr.isTTY?process.stderr.columns:void 0,outputError:(e,t)=>t(e)},this._hidden=!1,this._hasHelpOption=!0,this._helpFlags="-h, --help",this._helpDescription="display help for command",this._helpShortFlag="-h",this._helpLongFlag="--help",this._addImplicitHelpCommand=void 0,this._helpCommandName="help",this._helpCommandnameAndArgs="help [command]",this._helpCommandDescription="display help for command",this._helpConfiguration={}}command(e,t,r){let s=t,n=r;"object"==typeof s&&null!==s&&(n=s,s=null),n=n||{};const o=e.split(/ +/),i=this.createCommand(o.shift());return s&&(i.description(s),i._executableHandler=!0),n.isDefault&&(this._defaultCommandName=i._name),i._outputConfiguration=this._outputConfiguration,i._hidden=!(!n.noHelp&&!n.hidden),i._hasHelpOption=this._hasHelpOption,i._helpFlags=this._helpFlags,i._helpDescription=this._helpDescription,i._helpShortFlag=this._helpShortFlag,i._helpLongFlag=this._helpLongFlag,i._helpCommandName=this._helpCommandName,i._helpCommandnameAndArgs=this._helpCommandnameAndArgs,i._helpCommandDescription=this._helpCommandDescription,i._helpConfiguration=this._helpConfiguration,i._exitCallback=this._exitCallback,i._storeOptionsAsProperties=this._storeOptionsAsProperties,i._combineFlagAndOptionalValue=this._combineFlagAndOptionalValue,i._allowExcessArguments=this._allowExcessArguments,i._enablePositionalOptions=this._enablePositionalOptions,i._executableFile=n.executableFile||null,this.commands.push(i),i._parseExpectedArgs(o),i.parent=this,s?this:i}createCommand(e){return new h(e)}createHelp(){return Object.assign(new s,this.configureHelp())}configureHelp(e){return void 0===e?this._helpConfiguration:(this._helpConfiguration=e,this)}configureOutput(e){return void 0===e?this._outputConfiguration:(Object.assign(this._outputConfiguration,e),this)}addCommand(e,t){if(!e._name)throw new Error("Command passed to .addCommand() must have a name");return function e(t){t.forEach((t=>{if(t._executableHandler&&!t._executableFile)throw new Error(`Must specify executableFile for deeply nested executable: ${t.name()}`);e(t.commands)}))}(e.commands),(t=t||{}).isDefault&&(this._defaultCommandName=e._name),(t.noHelp||t.hidden)&&(e._hidden=!0),this.commands.push(e),e.parent=this,this}arguments(e){return this._parseExpectedArgs(e.split(/ +/))}addHelpCommand(e,t){return!1===e?this._addImplicitHelpCommand=!1:(this._addImplicitHelpCommand=!0,"string"==typeof e&&(this._helpCommandName=e.split(" ")[0],this._helpCommandnameAndArgs=e),this._helpCommandDescription=t||this._helpCommandDescription),this}_hasImplicitHelpCommand(){return void 0===this._addImplicitHelpCommand?this.commands.length&&!this._actionHandler&&!this._findCommand("help"):this._addImplicitHelpCommand}_parseExpectedArgs(e){if(e.length)return e.forEach((e=>{const t={required:!1,name:"",variadic:!1};switch(e[0]){case"<":t.required=!0,t.name=e.slice(1,-1);break;case"[":t.name=e.slice(1,-1)}t.name.length>3&&"..."===t.name.slice(-3)&&(t.variadic=!0,t.name=t.name.slice(0,-3)),t.name&&this._args.push(t)})),this._args.forEach(((e,t)=>{if(e.variadic&&t<this._args.length-1)throw new Error(`only the last argument can be variadic '${e.name}'`)})),this}exitOverride(e){return this._exitCallback=e||(e=>{if("commander.executeSubCommandAsync"!==e.code)throw e}),this}_exit(e,t,r){this._exitCallback&&this._exitCallback(new u(e,t,r)),process.exit(e)}action(e){return this._actionHandler=t=>{const r=this._args.length,s=t.slice(0,r);this._storeOptionsAsProperties?s[r]=this:s[r]=this.opts(),s.push(this);const n=e.apply(this,s);let o=this;for(;o.parent;)o=o.parent;o._actionResults.push(n)},this}createOption(e,t){return new n(e,t)}addOption(e){const t=e.name(),r=e.attributeName();let s=e.defaultValue;if(e.negate||e.optional||e.required||"boolean"==typeof s){if(e.negate){const t=e.long.replace(/^--no-/,"--");s=!this._findOption(t)||this._getOptionValue(r)}void 0!==s&&this._setOptionValue(r,s)}return this.options.push(e),this.on("option:"+t,(t=>{const n=this._getOptionValue(r);if(null!==t&&e.parseArg)try{t=e.parseArg(t,void 0===n?s:n)}catch(r){if("commander.invalidOptionArgument"===r.code){const s=`error: option '${e.flags}' argument '${t}' is invalid. ${r.message}`;this._displayError(r.exitCode,r.code,s)}throw r}else null!==t&&e.variadic&&(t=n!==s&&Array.isArray(n)?n.concat(t):[t]);"boolean"==typeof n||void 0===n?null==t?this._setOptionValue(r,!e.negate&&(s||!0)):this._setOptionValue(r,t):null!==t&&this._setOptionValue(r,!e.negate&&t)})),this}_optionEx(e,t,r,s,n){const o=this.createOption(t,r);if(o.makeOptionMandatory(!!e.mandatory),"function"==typeof s)o.default(n).argParser(s);else if(s instanceof RegExp){const e=s;s=(t,r)=>{const s=e.exec(t);return s?s[0]:r},o.default(n).argParser(s)}else o.default(s);return this.addOption(o)}option(e,t,r,s){return this._optionEx({},e,t,r,s)}requiredOption(e,t,r,s){return this._optionEx({mandatory:!0},e,t,r,s)}combineFlagAndOptionalValue(e=!0){return this._combineFlagAndOptionalValue=!!e,this}allowUnknownOption(e=!0){return this._allowUnknownOption=!!e,this}allowExcessArguments(e=!0){return this._allowExcessArguments=!!e,this}enablePositionalOptions(e=!0){return this._enablePositionalOptions=!!e,this}passThroughOptions(e=!0){if(this._passThroughOptions=!!e,this.parent&&e&&!this.parent._enablePositionalOptions)throw new Error("passThroughOptions can not be used without turning on enablePositionOptions for parent command(s)");return this}storeOptionsAsProperties(e=!0){if(this._storeOptionsAsProperties=!!e,this.options.length)throw new Error("call .storeOptionsAsProperties() before adding options");return this}_setOptionValue(e,t){this._storeOptionsAsProperties?this[e]=t:this._optionValues[e]=t}_getOptionValue(e){return this._storeOptionsAsProperties?this[e]:this._optionValues[e]}parse(e,t){if(void 0!==e&&!Array.isArray(e))throw new Error("first parameter to parse must be array or undefined");let r;switch(t=t||{},void 0===e&&(e=process.argv,process.versions&&process.versions.electron&&(t.from="electron")),this.rawArgs=e.slice(),t.from){case void 0:case"node":this._scriptPath=e[1],r=e.slice(2);break;case"electron":process.defaultApp?(this._scriptPath=e[1],r=e.slice(2)):r=e.slice(1);break;case"user":r=e.slice(0);break;default:throw new Error(`unexpected parse option { from: '${t.from}' }`)}return!this._scriptPath&&process.mainModule&&(this._scriptPath=process.mainModule.filename),this._name=this._name||this._scriptPath&&c.default.basename(this._scriptPath,c.default.extname(this._scriptPath)),this._parseCommand([],r),this}parseAsync(e,t){return this.parse(e,t),Promise.all(this._actionResults).then((()=>this))}_executeSubCommand(e,t){t=t.slice();let r=!1;const s=[".js",".ts",".tsx",".mjs"];this._checkForMissingMandatoryOptions();let n,i=this._scriptPath;!i&&process.mainModule&&(i=process.mainModule.filename);try{const e=o.default.realpathSync(i);n=c.default.dirname(e)}catch(e){n="."}let l=c.default.basename(i,c.default.extname(i))+"-"+e._name;e._executableFile&&(l=e._executableFile);const h=c.default.join(n,l);let p;o.default.existsSync(h)?l=h:s.forEach((e=>{o.default.existsSync(`${h}${e}`)&&(l=`${h}${e}`)})),r=s.includes(c.default.extname(l)),"win32"!==process.platform?r?(t.unshift(l),t=_(process.execArgv).concat(t),p=a.default.spawn(process.argv[0],t,{stdio:"inherit"})):p=a.default.spawn(l,t,{stdio:"inherit"}):(t.unshift(l),t=_(process.execArgv).concat(t),p=a.default.spawn(process.execPath,t,{stdio:"inherit"})),["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((e=>{process.on(e,(()=>{!1===p.killed&&null===p.exitCode&&p.kill(e)}))}));const m=this._exitCallback;m?p.on("close",(()=>{m(new u(process.exitCode||0,"commander.executeSubCommandAsync","(close)"))})):p.on("close",process.exit.bind(process)),p.on("error",(t=>{if("ENOENT"===t.code){const t=`'${l}' does not exist\n - if '${e._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;throw new Error(t)}if("EACCES"===t.code)throw new Error(`'${l}' not executable`);if(m){const e=new u(1,"commander.executeSubCommandAsync","(error)");e.nestedError=t,m(e)}else process.exit(1)})),this.runningCommand=p}_dispatchSubcommand(e,t,r){const s=this._findCommand(e);s||this.help({error:!0}),s._executableHandler?this._executeSubCommand(s,t.concat(r)):s._parseCommand(t,r)}_parseCommand(e,t){const r=this.parseOptions(t);if(e=e.concat(r.operands),t=r.unknown,this.args=e.concat(t),e&&this._findCommand(e[0]))this._dispatchSubcommand(e[0],e.slice(1),t);else if(this._hasImplicitHelpCommand()&&e[0]===this._helpCommandName)1===e.length?this.help():this._dispatchSubcommand(e[1],[],[this._helpLongFlag]);else if(this._defaultCommandName)p(this,t),this._dispatchSubcommand(this._defaultCommandName,e,t);else{!this.commands.length||0!==this.args.length||this._actionHandler||this._defaultCommandName||this.help({error:!0}),p(this,r.unknown),this._checkForMissingMandatoryOptions(),r.unknown.length>0&&this.unknownOption(r.unknown[0]);const s=`command:${this.name()}`;if(this._actionHandler){const r=this.args.slice();this._args.forEach(((e,t)=>{e.required&&null==r[t]?this.missingArgument(e.name):e.variadic&&(r[t]=r.splice(t),r.length=Math.min(t+1,r.length))})),r.length>this._args.length&&this._excessArguments(r),this._actionHandler(r),this.parent&&this.parent.emit(s,e,t)}else this.parent&&this.parent.listenerCount(s)?this.parent.emit(s,e,t):e.length?this._findCommand("*")?this._dispatchSubcommand("*",e,t):this.listenerCount("command:*")?this.emit("command:*",e,t):this.commands.length&&this.unknownCommand():this.commands.length&&this.help({error:!0})}}_findCommand(e){if(e)return this.commands.find((t=>t._name===e||t._aliases.includes(e)))}_findOption(e){return this.options.find((t=>t.is(e)))}_checkForMissingMandatoryOptions(){for(let e=this;e;e=e.parent)e.options.forEach((t=>{t.mandatory&&void 0===e._getOptionValue(t.attributeName())&&e.missingMandatoryOptionValue(t)}))}parseOptions(e){const t=[],r=[];let s=t;const n=e.slice();function o(e){return e.length>1&&"-"===e[0]}let i=null;for(;n.length;){const e=n.shift();if("--"===e){s===r&&s.push(e),s.push(...n);break}if(!i||o(e)){if(i=null,o(e)){const t=this._findOption(e);if(t){if(t.required){const e=n.shift();void 0===e&&this.optionMissingArgument(t),this.emit(`option:${t.name()}`,e)}else if(t.optional){let e=null;n.length>0&&!o(n[0])&&(e=n.shift()),this.emit(`option:${t.name()}`,e)}else this.emit(`option:${t.name()}`);i=t.variadic?t:null;continue}}if(e.length>2&&"-"===e[0]&&"-"!==e[1]){const t=this._findOption(`-${e[1]}`);if(t){t.required||t.optional&&this._combineFlagAndOptionalValue?this.emit(`option:${t.name()}`,e.slice(2)):(this.emit(`option:${t.name()}`),n.unshift(`-${e.slice(2)}`));continue}}if(/^--[^=]+=/.test(e)){const t=e.indexOf("="),r=this._findOption(e.slice(0,t));if(r&&(r.required||r.optional)){this.emit(`option:${r.name()}`,e.slice(t+1));continue}}if(o(e)&&(s=r),(this._enablePositionalOptions||this._passThroughOptions)&&0===t.length&&0===r.length){if(this._findCommand(e)){t.push(e),n.length>0&&r.push(...n);break}if(e===this._helpCommandName&&this._hasImplicitHelpCommand()){t.push(e),n.length>0&&t.push(...n);break}if(this._defaultCommandName){r.push(e),n.length>0&&r.push(...n);break}}if(this._passThroughOptions){s.push(e),n.length>0&&s.push(...n);break}s.push(e)}else this.emit(`option:${i.name()}`,e)}return{operands:t,unknown:r}}opts(){if(this._storeOptionsAsProperties){const e={},t=this.options.length;for(let r=0;r<t;r++){const t=this.options[r].attributeName();e[t]=t===this._versionOptionName?this._version:this[t]}return e}return this._optionValues}_displayError(e,t,r){this._outputConfiguration.outputError(`${r}\n`,this._outputConfiguration.writeErr),this._exit(e,t,r)}missingArgument(e){const t=`error: missing required argument '${e}'`;this._displayError(1,"commander.missingArgument",t)}optionMissingArgument(e){const t=`error: option '${e.flags}' argument missing`;this._displayError(1,"commander.optionMissingArgument",t)}missingMandatoryOptionValue(e){const t=`error: required option '${e.flags}' not specified`;this._displayError(1,"commander.missingMandatoryOptionValue",t)}unknownOption(e){if(this._allowUnknownOption)return;const t=`error: unknown option '${e}'`;this._displayError(1,"commander.unknownOption",t)}_excessArguments(e){if(this._allowExcessArguments)return;const t=this._args.length,r=1===t?"":"s",s=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${t} argument${r} but got ${e.length}.`;this._displayError(1,"commander.excessArguments",s)}unknownCommand(){const e=[this.name()];for(let t=this.parent;t;t=t.parent)e.unshift(t.name());const t=e.join(" "),r=`error: unknown command '${this.args[0]}'.`+(this._hasHelpOption?` See '${t} ${this._helpLongFlag}'.`:"");this._displayError(1,"commander.unknownCommand",r)}version(e,t,r){if(void 0===e)return this._version;this._version=e,t=t||"-V, --version",r=r||"output the version number";const s=this.createOption(t,r);return this._versionOptionName=s.attributeName(),this.options.push(s),this.on("option:"+s.name(),(()=>{this._outputConfiguration.writeOut(`${e}\n`),this._exit(0,"commander.version",e)})),this}description(e,t){return void 0===e&&void 0===t?this._description:(this._description=e,this._argsDescription=t,this)}alias(e){if(void 0===e)return this._aliases[0];let t=this;if(0!==this.commands.length&&this.commands[this.commands.length-1]._executableHandler&&(t=this.commands[this.commands.length-1]),e===t._name)throw new Error("Command alias can't be the same as its name");return t._aliases.push(e),this}aliases(e){return void 0===e?this._aliases:(e.forEach((e=>this.alias(e))),this)}usage(e){if(void 0===e){if(this._usage)return this._usage;const e=this._args.map((e=>m(e)));return[].concat(this.options.length||this._hasHelpOption?"[options]":[],this.commands.length?"[command]":[],this._args.length?e:[]).join(" ")}return this._usage=e,this}name(e){return void 0===e?this._name:(this._name=e,this)}helpInformation(e){const t=this.createHelp();return void 0===t.helpWidth&&(t.helpWidth=e&&e.error?this._outputConfiguration.getErrHelpWidth():this._outputConfiguration.getOutHelpWidth()),t.formatHelp(this,t)}_getHelpContext(e){const t={error:!!(e=e||{}).error};let r;return r=t.error?e=>this._outputConfiguration.writeErr(e):e=>this._outputConfiguration.writeOut(e),t.write=e.write||r,t.command=this,t}outputHelp(e){let t;"function"==typeof e&&(t=e,e=void 0);const r=this._getHelpContext(e),s=[];let n=this;for(;n;)s.push(n),n=n.parent;s.slice().reverse().forEach((e=>e.emit("beforeAllHelp",r))),this.emit("beforeHelp",r);let o=this.helpInformation(r);if(t&&(o=t(o),"string"!=typeof o&&!Buffer.isBuffer(o)))throw new Error("outputHelp callback must return a string or a Buffer");r.write(o),this.emit(this._helpLongFlag),this.emit("afterHelp",r),s.forEach((e=>e.emit("afterAllHelp",r)))}helpOption(e,t){if("boolean"==typeof e)return this._hasHelpOption=e,this;this._helpFlags=e||this._helpFlags,this._helpDescription=t||this._helpDescription;const r=d(this._helpFlags);return this._helpShortFlag=r.shortFlag,this._helpLongFlag=r.longFlag,this}help(e){this.outputHelp(e);let t=process.exitCode||0;0===t&&e&&"function"!=typeof e&&e.error&&(t=1),this._exit(t,"commander.help","(outputHelp)")}addHelpText(e,t){const r=["beforeAll","before","after","afterAll"];if(!r.includes(e))throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${r.join("', '")}'`);const s=`${e}Help`;return this.on(s,(e=>{let r;r="function"==typeof t?t({error:e.error,command:e.command}):t,r&&e.write(`${r}\n`)})),this}}function p(e,t){e._hasHelpOption&&t.find((t=>t===e._helpLongFlag||t===e._helpShortFlag))&&(e.outputHelp(),e._exit(0,"commander.helpDisplayed","(outputHelp)"))}function m(e){const t=e.name+(!0===e.variadic?"...":"");return e.required?"<"+t+">":"["+t+"]"}function d(e){let t,r;const s=e.split(/[ |,]+/);return s.length>1&&!/^[[<]/.test(s[1])&&(t=s.shift()),r=s.shift(),!t&&/^-[^-]$/.test(r)&&(t=r,r=void 0),{shortFlag:t,longFlag:r}}function _(e){return e.map((e=>{if(!e.startsWith("--inspect"))return e;let t,r,s="127.0.0.1",n="9229";return null!==(r=e.match(/^(--inspect(-brk)?)$/))?t=r[1]:null!==(r=e.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))?(t=r[1],/^\d+$/.test(r[3])?n=r[3]:s=r[3]):null!==(r=e.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))&&(t=r[1],s=r[3],n=r[4]),t&&"0"!==n?`${t}=${s}:${parseInt(n)+1}`:e}))}(t=e.exports=new h).program=t,t.Command=h,t.Option=n,t.CommanderError=u,t.InvalidOptionArgumentError=l,t.Help=s}(Lo={exports:{}},Lo.exports),Lo.exports);class Mo{constructor(e,t,r=!1){var s;this.hasAction=!1,this.program=e,this.options=Object.assign({},t),this.isSubcommand=r,this.options.flags=null!==(s=t.flags)&&void 0!==s?s:{help:{short:Mo.SHORT_HELP_FLAG,long:Mo.LONG_HELP_FLAG},language:{short:Mo.SHORT_LANG_FLAG,long:Mo.LONG_LANG_FLAG},version:{short:Mo.SHORT_VERSION_FLAG,long:Mo.LONG_VERSION_FLAG},in:{short:Mo.SHORT_INPUT_FLAG,long:Mo.LONG_INPUT_FLAG},out:{short:Mo.SHORT_OUTPUT_FLAG,long:Mo.LONG_OUTPUT_FLAG}}}input(e,t){return this.onReadErrorMsg=t,this.program.option(`${this.options.flags.in.short}, ${this.options.flags.in.long}, <filename>`,this.options.translator?this.options.translator.translate(e):e),this}output(e){return this.program.option(`${this.options.flags.out.short}, ${this.options.flags.out.long}, <filename>`,this.options.translator?this.options.translator.translate(e):e),this}option(e,t,r){return this.program.option(e,this.options.translator?this.options.translator.translate(t):t,r),this}action(e){return this.program.action(((...t)=>{this.currentArgs=t.length>=2?t.slice(0,t.length-2):[t[0]],this.currentOptions=t.length>=2?t[t.length-2]:t[1],this.setCorrectLanguage(this.currentOptions.language),e(this,...t)})),this.hasAction=!0,this}read(){return this.currentOptions&&this.currentOptions.in?this.readFileInput(this.currentOptions.in):this.currentArgs.join(" ")}write(e){this.currentOptions&&this.currentOptions.out?this.writeToFile(this.currentOptions.out,e):this.writeToConsole(e)}readFileInput(e){return this.ensureOrFailAndExit(o.default.existsSync(e),this.options.translator?this.options.translator.translate(this.onReadErrorMsg,{fileName:e}):this.onReadErrorMsg),o.default.readFileSync(e).toString()}writeToFile(e,t){o.default.writeFileSync(e,t,{flag:"a"})}writeToConsole(e){console.log(e)}ensureOrFailAndExit(e,t){e||(this.writeToConsole(t),this.exit(1))}hasNoArgs(){const e=process.argv.slice(this.isSubcommand?3:2);return 0===e.length||2===e.length&&(e[0]===this.options.flags.language.short||e[0]===this.options.flags.language.long)}outputHelp(){this.program.outputHelp()}outputHelpOnNoArgs(){this.hasNoArgs()&&(this.outputHelp(),this.exit(0))}exit(e){process.exit(e)}setCorrectLanguage(e){e&&(this.validateLanguageFlag(e),this.options.translator.setLocale(e))}validateLanguageFlag(e){const t=Object.keys(this.options.translator.getAvailableTranslations()).map((e=>'"'+e+'"')).join(" | ");this.ensureOrFailAndExit(this.options.translator.hasLocale(e),this.options.translator?this.options.translator.translate(this.options.texts.languageError,{locale:e,availableLangs:t}):this.options.texts.languageError)}}Mo.SHORT_HELP_FLAG="-h",Mo.SHORT_VERSION_FLAG="-v",Mo.SHORT_LANG_FLAG="-l",Mo.SHORT_INPUT_FLAG="-i",Mo.SHORT_OUTPUT_FLAG="-o",Mo.LONG_HELP_FLAG="--help",Mo.LONG_VERSION_FLAG="--version",Mo.LONG_LANG_FLAG="--language",Mo.LONG_INPUT_FLAG="--in",Mo.LONG_OUTPUT_FLAG="--out";class Fo extends Mo{constructor(e){super(Ao.program,e),this.processArgs=process.argv,this.setCorrectLanguage(this.getUserEnvLocale()),this.setLanguageIfConfigured(this.program),this.program.name(this.options.texts.name),this.program.version(this.options.texts.versionNumber,`${this.options.flags.version.short}, ${this.options.flags.version.long}`,this.options.translator?this.options.translator.translate(this.options.texts.version):this.options.texts.version),this.program.helpOption(`${this.options.flags.help.short}, ${this.options.flags.help.long}`,this.options.translator?this.options.translator.translate(this.options.texts.help):this.options.texts.help),this.program.addHelpCommand(!1)}run(){this.hasAction||this.program.action((e=>{this.setCorrectLanguage(e.language),this.outputHelpOnNoArgs()})),this.program.parse(this.processArgs)}command(e,t,r){const s=this.program.command(e).description(this.options.translator?this.options.translator.translate(t):t);return this.setLanguageIfConfigured(s),r(new Mo(s,this.options,!0)),this}setLanguageIfConfigured(e){if(this.options.translator){const t=this.getUserLocale();this.setCorrectLanguage(t);const r=Object.keys(this.options.translator.getAvailableTranslations()).map((e=>'"'+e+'"')).join(" | ");e.option(`${this.options.flags.language.short}, ${this.options.flags.language.long}, <locale>`,this.options.translator.translate(this.options.texts.language,{availableLangs:r}),t)}}getUserLocale(){const e=this.getUserEnvLocale();if(this.processArgs.indexOf(this.options.flags.language.short)>=0||this.processArgs.indexOf(this.options.flags.language.long)>=0){const t=this.processArgs.indexOf(this.options.flags.language.short)>=0?this.processArgs.indexOf(this.options.flags.language.short):this.processArgs.indexOf(this.options.flags.language.long);return this.processArgs.length>t?this.processArgs[t+1]:e}return e}getUserEnvLocale(){var e,t,r,s,n,o;const i=null!==(e=process.env)&&void 0!==e?e:{},a=null!==(n=null!==(s=null!==(r=null!==(t=i.LANG)&&void 0!==t?t:i.LANGUAGE)&&void 0!==r?r:i.LC_NAME)&&void 0!==s?s:i.LC_ALL)&&void 0!==n?n:i.LC_MESSAGES,c=null===(o=null==a?void 0:a.split("."))||void 0===o?void 0:o[0],u=void 0!==c?[c,c.split("_")[0]]:[];if(u.length>0)for(const e of u)if(this.options.translator.hasLocale(e))return e;return this.options.translator.getDefaultLocale()}}const Bo=(e,t)=>!(!Number.isNaN(e)||!Number.isNaN(t))||e===t,Do=(e,t,r)=>{if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(!r(e[s],t[s]))return!1;return!0},Vo=(e,t,r)=>{const s=Object.keys(e).sort(),n=Object.keys(t).sort();if(s.length!==n.length)return!1;for(let e=0;e<s.length;e++)if(s[e]!==n[e])return!1;for(let n=0;n<s.length;n++){if(!r(e[s[n]],t[s[n]]))return!1}return!0},Ho=(e,t)=>{if(e.size!==t.size)return!1;const r=e.entries();let s=r.next();for(;s&&!s.done;){if(!t.has(s.value[1]))return!1;s=r.next()}return!0},Go=(e,t,r)=>{if(e.size!==t.size)return!1;const s=e.entries();let n=s.next();for(;!n.done;){if(!t.has(n.value[0]))return!1;if(!r(n.value[1],t.get(n.value[0])))return!1;n=s.next()}return!0},Uo=(e,t)=>e.name===t.name&&e.message===t.message,$o=(e,t)=>e.source===t.source&&e.flags===t.flags,jo=(e,t)=>e.getTime()===t.getTime(),Wo=(e,t)=>{if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0},qo=e=>!!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e));class zo{orThrow(e){if(!this.getResult())throw e}orYield(e){return this.getResult()?void 0:e}andDoOr(e,t){this.getResult()?e():t()}andDo(e){this.andDoOr(e,(()=>{}))}orDo(e){this.andDoOr((()=>{}),e)}}class Yo extends zo{constructor(e){super(),this.states=[],this.element=e,this.isNot=!1}get not(){return this.isNot=!this.isNot,this}toBe(e){return this.runMatcher("toBe",[e])}toBeLike(e){return this.runMatcher("toBeLike",[e])}toBeNull(){return this.runMatcher("toBeNull",[])}toBeDefined(){return this.runMatcher("toBeDefined",[])}toBeUndefined(){return this.runMatcher("toBeUndefined",[])}toBeTruthy(){return this.runMatcher("toBeTruthy",[])}toBeFalsy(){return this.runMatcher("toBeFalsy",[])}toHaveType(e){return this.runMatcher("toHaveType",[e])}toBeGreaterThan(e){return this.runMatcher("toBeGreaterThan",[e])}toBeGreaterThanOrEqual(e){return this.runMatcher("toBeGreaterThanOrEqual",[e])}toBeLowerThan(e){return this.runMatcher("toBeLowerThan",[e])}toBeLowerThanOrEqual(e){return this.runMatcher("toBeLowerThanOrEqual",[e])}toBeBetween(e,t){return this.runMatcher("toBeBetween",[e,t])}toBeInfinity(){return this.runMatcher("toBeInfinity",[])}toBeNaN(){return this.runMatcher("toBeNaN",[])}toBeCloseTo(e,t=5){return this.runMatcher("toBeCloseTo",[e,t])}toHaveSubstring(e){return this.runMatcher("toHaveSubstring",[e])}toStartWith(e){return this.runMatcher("toStartWith",[e])}toEndWith(e){return this.runMatcher("toEndWith",[e])}toMatch(e){return this.runMatcher("toMatch",[e])}toHaveLength(e){return this.runMatcher("toHaveLength",[e])}toContain(e){return this.runMatcher("toContain",[e])}toHaveAtPosition(e,t){return this.runMatcher("toHaveAtPosition",[e,t])}allToSatisfy(e){return this.runMatcher("allToSatisfy",[e])}anyToSatisfy(e){return this.runMatcher("anyToSatisfy",[e])}amountToSatisfy(e,t){return this.runMatcher("amountToSatisfy",[e,t])}toHavePropertyCount(e){return this.runMatcher("toHavePropertyCount",[e])}toHaveAtLeast(e){return this.runMatcher("toHaveAtLeast",e,!1)}toHaveNoOtherThan(e){return this.runMatcher("toHaveNoOtherThan",e,!1)}toHaveProperty(e){return this.runMatcher("toHaveProperty",[e])}toBeInstanceOf(e){return this.runMatcher("toBeInstanceOf",[e])}getResult(){return this.result}setResult(e){void 0===this.result?this.result=e:this.result=this.result&&e}runMatcher(e,t,r=!0){const s=r?[this.element,...t]:[this.element,t],n=class{static toBe(e,t){return e===t}static toBeLike(e,t){return((e,t)=>{const r=(e,t)=>e===t||typeof e==typeof t&&("number"==typeof e&&"number"==typeof t?Bo(e,t):"object"==typeof e&&"object"==typeof t&&(!e.constructor||!t.constructor||e.constructor===t.constructor)&&(Array.isArray(e)&&Array.isArray(t)?Do(e,t,r):e instanceof Set&&t instanceof Set?Ho(e,t):e instanceof Map&&t instanceof Map?Go(e,t,r):e instanceof Error&&t instanceof Error?Uo(e,t):e instanceof RegExp&&t instanceof RegExp?$o(e,t):e instanceof Date&&t instanceof Date?jo(e,t):qo(e)&&qo(t)?Wo(e,t):Vo(e,t,r)));return r(e,t)})(e,t)}static toBeDefined(e){return void 0!==e}static toBeUndefined(e){return void 0===e}static toBeNull(e){return null===e}static toBeTruthy(e){return!!e}static toBeFalsy(e){return!e}static toHaveType(e,t){return"object"!==t&&typeof e===t||"array"===t&&"object"==typeof e&&Array.isArray(e)||"object"===t&&!Array.isArray(e)&&typeof e===t}static toBeGreaterThan(e,t){return"number"==typeof e&&e>t}static toBeGreaterThanOrEqual(e,t){return"number"==typeof e&&e>=t}static toBeLowerThan(e,t){return"number"==typeof e&&e<t}static toBeLowerThanOrEqual(e,t){return"number"==typeof e&&e<=t}static toBeBetween(e,t,r){return"number"==typeof e&&t<=e&&e<=r}static toBeInfinity(e){return"number"==typeof e&&(e===1/0||e===-1/0)}static toBeNaN(e){return"number"==typeof e&&Number.isNaN(e)}static toBeCloseTo(e,t,r){return"number"==typeof e&&Math.abs(t-e)<Math.pow(10,-r)/10}static toHaveSubstring(e,t){return"string"==typeof e&&e.indexOf(t)>=0}static toStartWith(e,t){return"string"==typeof e&&e.startsWith(t)}static toEndWith(e,t){return"string"==typeof e&&e.endsWith(t)}static toMatch(e,t){return"string"==typeof e&&t.test(e)}static toHaveLength(e,t){return"object"==typeof e&&e instanceof Array&&e.length===t}static toContain(e,t){return"object"==typeof e&&Array.isArray(e)&&e.indexOf(t)>=0}static toHaveAtPosition(e,t,r){return"object"==typeof e&&Array.isArray(e)&&e.length>r&&r>=0&&e[r]===t}static allToSatisfy(e,t){return"object"==typeof e&&Array.isArray(e)&&e.reduce(((e,r)=>t(r)&&e),!0)}static anyToSatisfy(e,t){return"object"==typeof e&&Array.isArray(e)&&e.reduce(((e,r)=>t(r)||e),!1)}static amountToSatisfy(e,t,r){return"object"==typeof e&&Array.isArray(e)&&e.reduce(((e,t)=>r(t)?e+1:e),0)===t}static toHavePropertyCount(e,t){return"object"==typeof e&&Object.keys(e).filter((t=>Object.hasOwnProperty.call(e,t))).length===t}static toHaveAtLeast(e,t){if("object"!=typeof e)return!1;for(const r of t)if(!e[r])return!1;return!0}static toHaveNoOtherThan(e,t){if("object"!=typeof e)return!1;for(const r of Object.keys(e))if(t.indexOf(r)<0)return!1;return!0}static toHaveProperty(e,t){return"object"==typeof e&&Object.prototype.hasOwnProperty.call(e,t)}static toBeInstanceOf(e,t){return"object"==typeof e&&e instanceof t}}[e].call(this,...s),o=this.isNot?!n:n;return this.states.push({matcher:e,args:t,result:o}),this.setResult(o),this}}class Jo extends zo{constructor(e,t){super(),this.result=t(e)}getResult(){return this.result}}function Ko(e){return new Yo(e)}var Qo,Zo;!function(e){e.and=(...e)=>new Jo(e,(e=>e.reduce(((e,t)=>e&&t.getResult()),!0))),e.or=(...e)=>new Jo(e,(e=>e.reduce(((e,t)=>e||t.getResult()),!1)))}(Ko||(Ko={})),i.default.EventEmitter,function(e){e.Blue="a",e.Black="n",e.Red="r",e.Green="v"}(Qo||(Qo={})),function(e){e.min=()=>e.Blue,e.max=()=>e.Green,e.next=t=>{switch(t){case e.Blue:return e.Black;case e.Black:return e.Red;case e.Red:return e.Green;case e.Green:return e.Blue;default:return}},e.previous=t=>{switch(t){case e.Blue:return e.Green;case e.Black:return e.Blue;case e.Red:return e.Black;case e.Green:return e.Red;default:return}},e.foreach=function(t){let r=e.min();for(;r!==e.max();)t(r),r=e.next(r);t(r)}}(Qo||(Qo={})),function(e){e.North="n",e.East="e",e.South="s",e.West="w"}(Zo||(Zo={})),function(e){e.min=()=>e.North,e.max=()=>e.West,e.next=t=>{switch(t){case e.North:return e.East;case e.East:return e.South;case e.South:return e.West;case e.West:return e.North;default:return}},e.previous=t=>{switch(t){case e.North:return e.West;case e.East:return e.North;case e.South:return e.East;case e.West:return e.South;default:return}},e.opposite=t=>{switch(t){case e.North:return e.South;case e.East:return e.West;case e.South:return e.North;case e.West:return e.East;default:return}},e.isVertical=t=>t===e.North||t===e.South,e.isHorizontal=t=>!e.isVertical(t),e.foreach=t=>{let r=e.min();for(;r!==e.max();)t(r),r=e.next(r);t(r)}}(Zo||(Zo={})),Qo.Blue,Qo.Black,Qo.Red,Qo.Green;var Xo=ri;function ei(e){return e&&e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}function ti(e){return e}function ri(e,t){const r=(t=t||{}).delimiter||".",s=t.maxDepth,n=t.transformKey||ti,o={};return function e(i,a,c){c=c||1,Object.keys(i).forEach((function(u){const l=i[u],h=t.safe&&Array.isArray(l),p=Object.prototype.toString.call(l),m=ei(l),d="[object Object]"===p||"[object Array]"===p,_=a?a+r+n(u):n(u);if(!h&&!m&&d&&Object.keys(l).length&&(!t.maxDepth||c<s))return e(l,_,c+1);o[_]=l}))}(e),o}ri.flatten=ri,ri.unflatten=function e(t,r){const s=(r=r||{}).delimiter||".",n=r.overwrite||!1,o=r.transformKey||ti,i={};if(ei(t)||"[object Object]"!==Object.prototype.toString.call(t))return t;function a(e){const t=Number(e);return isNaN(t)||-1!==e.indexOf(".")||r.object?e:t}return t=Object.keys(t).reduce((function(e,n){const o=Object.prototype.toString.call(t[n]);return!("[object Object]"===o||"[object Array]"===o)||function(e){const t=Object.prototype.toString.call(e),r="[object Array]"===t,s="[object Object]"===t;if(!e)return!0;if(r)return!e.length;if(s)return!Object.keys(e).length}(t[n])?(e[n]=t[n],e):function(e,t,r){return Object.keys(r).reduce((function(t,n){return t[e+s+n]=r[n],t}),t)}(n,e,ri(t[n],r))}),{}),Object.keys(t).forEach((function(c){const u=c.split(s).map(o);let l=a(u.shift()),h=a(u[0]),p=i;for(;void 0!==h;){if("__proto__"===l)return;const e=Object.prototype.toString.call(p[l]),t="[object Object]"===e||"[object Array]"===e;if(!n&&!t&&void 0!==p[l])return;(n&&!t||!n&&null==p[l])&&(p[l]="number"!=typeof h||r.object?{}:[]),p=p[l],u.length>0&&(l=a(u.shift()),h=a(u[0]))}p[l]=e(t[c],r)})),i};const si=Xo.flatten;const ni={en:{cli:{descriptions:{tool:"The Gobstones Language Parser",version:"Show the version information",help:"Show the tool`s help",language:"Select the language in which the tool works internally",in:"Select the file to parse. If none given, the contents are expected inline",out:"Select the output file in which to save the results. If none given, the output is written to stdout"},errors:{language:'You specified "${lang}" as the language, but that\'s not a valid language. Select one of ${availableLangs}.',file:"The file ${fileName} does not exist or cannot be read."}}},es:{cli:{descriptions:{tool:"El parser del Lenguaje Gobstones",version:"Mostrar la información de versión",help:"Mostrar la ayuda de la herramienta",language:"Seleccionar el idioma en el que la herramienta funciona internamente",in:"Seleccionar el archivo a parsear. Si no se provee, los contenidos se esperan en la línea de comandos.",out:"Seleccionar el archivo de salida en el cual guardar los resultados. Si no se provee, los resultados se muestran en stdout"},errors:{language:'Especificaste el idioma "${lang}", pero no es un idioma válido, seleccione uno de ${availableLangs}.',file:"El archivo ${fileName} no existe o no se puede leer."}}}},oi=new class{constructor(e,t,r=!0,s){if(!e)throw new Error("The translations cannot be null nor undefined");if(!t)throw new Error("The default translation cannot be null nor undefined");if(!e[t])throw new Error("The default translation must be one of the translations available");this.availableTranslations=e,this.defaultLocale=t,this.flatten=r,this.setLocale(null!=s?s:t)}getDefaultLocale(){return this.defaultLocale}getAvailableTranslations(){return this.availableTranslations}getLocale(){return this.currentLocaleName}hasLocale(e){return!!this.availableTranslations[e]}setLocale(e){if(!this.availableTranslations[e])throw new Error(`The locale "${e}" is not available`);this.currentLocaleName=e,this.currentLocale=this.flatten?si(this.availableTranslations[this.currentLocaleName]):this.availableTranslations[this.currentLocaleName]}translate(e,t){let r=this.currentLocale[e];if(!r||"string"!=typeof r)return e;for(const e in t||[])r=r.replace(`\${${e}}`,`${t[e]}`);return r}}(ni,"en"),ii=require("../package.json"),ai=ii.name.split("/").slice(-1).pop(),ci=ii.version;var ui;(ui={translator:oi,texts:{name:ai,versionNumber:ci,help:"cli.descriptions.help",tool:"cli.descriptions.tool",language:"cli.descriptions.language",languageError:"cli.errors.language",version:"cli.descriptions.version"}},new Fo(ui)).command("run [code]","cli.parse.description",(e=>{e.input("cli.descriptions.in","cli.errors.file").option("--board, -b","cli.descriptions.board","board.jboard").output("cli.descriptions.out").action(((e,t,r)=>{e.outputHelpOnNoArgs();const s=((e,t)=>{const r=new Ro,s=new qn;return t&&s.load(t),r.runState(e,s).state.dump()})(e.read(),r.B?p(r.B):void 0),n=JSON.stringify(s,void 0,2);e.write(n)}))})).command("compile [code]","cli.parse.description",(e=>{e.input("cli.descriptions.in","cli.errors.file").option("board, b","cli.descriptions.board","").output("cli.descriptions.out").action(((e,t,r)=>{e.outputHelpOnNoArgs();const s=(e=>{const t=new Ro;return t.parse(e),t.lint(),t.compile(),t.virtualMachineCode.toString()})(e.read()),n=JSON.stringify(s,void 0,2);e.write(n)}))})).command("parse [code]","cli.parse.description",(e=>{e.input("cli.descriptions.in","cli.errors.file").option("board, b","cli.descriptions.board","").output("cli.descriptions.out").action(((e,t,r)=>{e.outputHelpOnNoArgs();const s=(e=>{const t=new Ro;t.parse(e);t.lint();

let ast = t.abstractSyntaxTree;ast.tagsToString();return JSON.stringify(ast)

})(e.read()),n=JSON.stringify(s,void 0,2);e.write(n)}))})).run();